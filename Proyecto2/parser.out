Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    SETMINVALUE
    COMMENT
    SIMPLEQUOTE
    RDOUBLEQUOTE
    SETMAXVALUE
    SETSIZE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM instructionType
Rule 2     program -> PROGRAM LCURLY RCURLY
Rule 3     instructionType -> LCURLY instructionBlock RCURLY SEMICOLON
Rule 4     instructionType -> instruction
Rule 5     declarationBlock -> types id SEMICOLON
Rule 6     declarationBlock -> types id SEMICOLON declarationBlock
Rule 7     types -> INT
Rule 8     types -> BOOL
Rule 9     types -> SET
Rule 10    id -> IDENTIFIER
Rule 11    id -> IDENTIFIER COMMA id
Rule 12    instructionBlock -> instruction SEMICOLON
Rule 13    instructionBlock -> instruction SEMICOLON instructionBlock
Rule 14    instruction -> USING declarationBlock IN instructionBlock
Rule 15    instruction -> IDENTIFIER ASSIGN expression
Rule 16    instruction -> IDENTIFIER ASSIGN LCURLY set RCURLY
Rule 17    instruction -> ifInst
Rule 18    instruction -> printOutput
Rule 19    instruction -> whileInst
Rule 20    instruction -> repeatInst
Rule 21    instruction -> forInst
Rule 22    instruction -> scanInst
Rule 23    set -> expression COMMA set
Rule 24    set -> expression
Rule 25    ifInst -> IF LPAREN expression RPAREN instructionType
Rule 26    ifInst -> IF LPAREN expression RPAREN instructionType ELSE instructionType
Rule 27    forInst -> FOR IDENTIFIER direction IDENTIFIER DO instructionType
Rule 28    forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
Rule 29    whileInst -> WHILE LPAREN expression RPAREN DO instructionType
Rule 30    repeatInst -> REPEAT instructionType whileInst
Rule 31    scanInst -> SCAN expression
Rule 32    direction -> MIN
Rule 33    direction -> MAX
Rule 34    printOutput -> PRINT outputType
Rule 35    printOutput -> PRINTLN outputType
Rule 36    outputType -> STRING
Rule 37    outputType -> expression
Rule 38    expression -> binaryOp
Rule 39    binaryOp -> binaryOp PLUS binaryOp
Rule 40    binaryOp -> binaryOp MINUS binaryOp
Rule 41    binaryOp -> binaryOp TIMES binaryOp
Rule 42    binaryOp -> binaryOp DIVIDE binaryOp
Rule 43    binaryOp -> binaryOp MODULE binaryOp
Rule 44    binaryOp -> binaryOp AND binaryOp
Rule 45    binaryOp -> binaryOp OR binaryOp
Rule 46    binaryOp -> NOT binaryOp
Rule 47    binaryOp -> MINUS binaryOp
Rule 48    binaryOp -> LPAREN binaryOp RPAREN
Rule 49    binaryOp -> binaryOp LESSTHAN binaryOp
Rule 50    binaryOp -> binaryOp LESSEQUALTHAN binaryOp
Rule 51    binaryOp -> binaryOp GREATERTHAN binaryOp
Rule 52    binaryOp -> binaryOp GREATEREQUALTHAN binaryOp
Rule 53    binaryOp -> binaryOp EQUALS binaryOp
Rule 54    binaryOp -> binaryOp NOTEQUALS binaryOp
Rule 55    binaryOp -> binaryOp SETUNION binaryOp
Rule 56    binaryOp -> binaryOp SETDIFF binaryOp
Rule 57    binaryOp -> binaryOp SETINTERSECT binaryOp
Rule 58    binaryOp -> binaryOp SETMAPPLUS binaryOp
Rule 59    binaryOp -> binaryOp SETMAPMINUS binaryOp
Rule 60    binaryOp -> binaryOp SETMAPTIMES binaryOp
Rule 61    binaryOp -> binaryOp SETMAPDIVIDE binaryOp
Rule 62    binaryOp -> binaryOp SETMAPMODULE binaryOp
Rule 63    binaryOp -> binaryOp BELONGSTO binaryOp
Rule 64    binaryOp -> TRUE
Rule 65    binaryOp -> FALSE
Rule 66    binaryOp -> number
Rule 67    binaryOp -> IDENTIFIER
Rule 68    number -> NUMBER

Terminals, with rules where they appear

AND                  : 44
ASSIGN               : 15 16
BELONGSTO            : 63
BOOL                 : 8
COMMA                : 11 23
COMMENT              : 
DIVIDE               : 42
DO                   : 27 28 29
ELSE                 : 26
EQUALS               : 53
FALSE                : 65
FOR                  : 27 28
GREATEREQUALTHAN     : 52
GREATERTHAN          : 51
IDENTIFIER           : 10 11 15 16 27 27 28 28 67
IF                   : 25 26
IN                   : 14
INT                  : 7
LCURLY               : 2 3 16 28
LESSEQUALTHAN        : 50
LESSTHAN             : 49
LPAREN               : 25 26 29 48
MAX                  : 33
MIN                  : 32
MINUS                : 40 47
MODULE               : 43
NOT                  : 46
NOTEQUALS            : 54
NUMBER               : 68
OR                   : 45
PLUS                 : 39
PRINT                : 34
PRINTLN              : 35
PROGRAM              : 1 2
RCURLY               : 2 3 16 28
RDOUBLEQUOTE         : 
REPEAT               : 30
RPAREN               : 25 26 29 48
SCAN                 : 31
SEMICOLON            : 3 5 6 12 13
SET                  : 9
SETDIFF              : 56
SETINTERSECT         : 57
SETMAPDIVIDE         : 61
SETMAPMINUS          : 59
SETMAPMODULE         : 62
SETMAPPLUS           : 58
SETMAPTIMES          : 60
SETMAXVALUE          : 
SETMINVALUE          : 
SETSIZE              : 
SETUNION             : 55
SIMPLEQUOTE          : 
STRING               : 36
TIMES                : 41
TRUE                 : 64
USING                : 14
WHILE                : 29
error                : 

Nonterminals, with rules where they appear

binaryOp             : 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 47 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63
declarationBlock     : 6 14
direction            : 27 28
expression           : 15 23 24 25 26 29 31 37
forInst              : 21
id                   : 5 6 11
ifInst               : 17
instruction          : 4 12 13
instructionBlock     : 3 13 14
instructionType      : 1 25 26 26 27 28 29 30
number               : 66
outputType           : 34 35
printOutput          : 18
program              : 0
repeatInst           : 20
scanInst             : 22
set                  : 16 23
types                : 5 6
whileInst            : 19 30

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM instructionType
    (2) program -> . PROGRAM LCURLY RCURLY

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . instructionType
    (2) program -> PROGRAM . LCURLY RCURLY
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 5
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    scanInst                       shift and go to state 7
    instruction                    shift and go to state 19
    instructionType                shift and go to state 10
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 2

    (0) S' -> program .



state 3

    (21) instruction -> forInst .

    WHILE           reduce using rule 21 (instruction -> forInst .)
    ELSE            reduce using rule 21 (instruction -> forInst .)
    $end            reduce using rule 21 (instruction -> forInst .)
    SEMICOLON       reduce using rule 21 (instruction -> forInst .)


state 4

    (31) scanInst -> SCAN . expression
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    expression                     shift and go to state 30
    number                         shift and go to state 21
    binaryOp                       shift and go to state 22

state 5

    (2) program -> PROGRAM LCURLY . RCURLY
    (3) instructionType -> LCURLY . instructionBlock RCURLY SEMICOLON
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    RCURLY          shift and go to state 31
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instructionBlock               shift and go to state 33
    scanInst                       shift and go to state 7
    instruction                    shift and go to state 32
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 6

    (29) whileInst -> WHILE . LPAREN expression RPAREN DO instructionType

    LPAREN          shift and go to state 34


state 7

    (22) instruction -> scanInst .

    WHILE           reduce using rule 22 (instruction -> scanInst .)
    ELSE            reduce using rule 22 (instruction -> scanInst .)
    $end            reduce using rule 22 (instruction -> scanInst .)
    SEMICOLON       reduce using rule 22 (instruction -> scanInst .)


state 8

    (34) printOutput -> PRINT . outputType
    (36) outputType -> . STRING
    (37) outputType -> . expression
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    STRING          shift and go to state 36
    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    expression                     shift and go to state 37
    outputType                     shift and go to state 35
    binaryOp                       shift and go to state 22
    number                         shift and go to state 21

state 9

    (19) instruction -> whileInst .

    WHILE           reduce using rule 19 (instruction -> whileInst .)
    ELSE            reduce using rule 19 (instruction -> whileInst .)
    $end            reduce using rule 19 (instruction -> whileInst .)
    SEMICOLON       reduce using rule 19 (instruction -> whileInst .)


state 10

    (1) program -> PROGRAM instructionType .

    $end            reduce using rule 1 (program -> PROGRAM instructionType .)


state 11

    (35) printOutput -> PRINTLN . outputType
    (36) outputType -> . STRING
    (37) outputType -> . expression
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    STRING          shift and go to state 36
    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    expression                     shift and go to state 37
    outputType                     shift and go to state 38
    binaryOp                       shift and go to state 22
    number                         shift and go to state 21

state 12

    (15) instruction -> IDENTIFIER . ASSIGN expression
    (16) instruction -> IDENTIFIER . ASSIGN LCURLY set RCURLY

    ASSIGN          shift and go to state 39


state 13

    (17) instruction -> ifInst .

    WHILE           reduce using rule 17 (instruction -> ifInst .)
    ELSE            reduce using rule 17 (instruction -> ifInst .)
    $end            reduce using rule 17 (instruction -> ifInst .)
    SEMICOLON       reduce using rule 17 (instruction -> ifInst .)


state 14

    (30) repeatInst -> REPEAT . instructionType whileInst
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 40
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    instruction                    shift and go to state 19
    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    scanInst                       shift and go to state 7
    instructionType                shift and go to state 41
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 15

    (18) instruction -> printOutput .

    WHILE           reduce using rule 18 (instruction -> printOutput .)
    ELSE            reduce using rule 18 (instruction -> printOutput .)
    $end            reduce using rule 18 (instruction -> printOutput .)
    SEMICOLON       reduce using rule 18 (instruction -> printOutput .)


state 16

    (27) forInst -> FOR . IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> FOR . IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType

    IDENTIFIER      shift and go to state 42


state 17

    (20) instruction -> repeatInst .

    WHILE           reduce using rule 20 (instruction -> repeatInst .)
    ELSE            reduce using rule 20 (instruction -> repeatInst .)
    $end            reduce using rule 20 (instruction -> repeatInst .)
    SEMICOLON       reduce using rule 20 (instruction -> repeatInst .)


state 18

    (25) ifInst -> IF . LPAREN expression RPAREN instructionType
    (26) ifInst -> IF . LPAREN expression RPAREN instructionType ELSE instructionType

    LPAREN          shift and go to state 43


state 19

    (4) instructionType -> instruction .

    ELSE            reduce using rule 4 (instructionType -> instruction .)
    $end            reduce using rule 4 (instructionType -> instruction .)
    SEMICOLON       reduce using rule 4 (instructionType -> instruction .)
    WHILE           reduce using rule 4 (instructionType -> instruction .)


state 20

    (14) instruction -> USING . declarationBlock IN instructionBlock
    (5) declarationBlock -> . types id SEMICOLON
    (6) declarationBlock -> . types id SEMICOLON declarationBlock
    (7) types -> . INT
    (8) types -> . BOOL
    (9) types -> . SET

    INT             shift and go to state 45
    BOOL            shift and go to state 46
    SET             shift and go to state 44

    types                          shift and go to state 47
    declarationBlock               shift and go to state 48

state 21

    (66) binaryOp -> number .

    PLUS            reduce using rule 66 (binaryOp -> number .)
    MINUS           reduce using rule 66 (binaryOp -> number .)
    TIMES           reduce using rule 66 (binaryOp -> number .)
    DIVIDE          reduce using rule 66 (binaryOp -> number .)
    MODULE          reduce using rule 66 (binaryOp -> number .)
    AND             reduce using rule 66 (binaryOp -> number .)
    OR              reduce using rule 66 (binaryOp -> number .)
    LESSTHAN        reduce using rule 66 (binaryOp -> number .)
    LESSEQUALTHAN   reduce using rule 66 (binaryOp -> number .)
    GREATERTHAN     reduce using rule 66 (binaryOp -> number .)
    GREATEREQUALTHAN reduce using rule 66 (binaryOp -> number .)
    EQUALS          reduce using rule 66 (binaryOp -> number .)
    NOTEQUALS       reduce using rule 66 (binaryOp -> number .)
    SETUNION        reduce using rule 66 (binaryOp -> number .)
    SETDIFF         reduce using rule 66 (binaryOp -> number .)
    SETINTERSECT    reduce using rule 66 (binaryOp -> number .)
    SETMAPPLUS      reduce using rule 66 (binaryOp -> number .)
    SETMAPMINUS     reduce using rule 66 (binaryOp -> number .)
    SETMAPTIMES     reduce using rule 66 (binaryOp -> number .)
    SETMAPDIVIDE    reduce using rule 66 (binaryOp -> number .)
    SETMAPMODULE    reduce using rule 66 (binaryOp -> number .)
    BELONGSTO       reduce using rule 66 (binaryOp -> number .)
    $end            reduce using rule 66 (binaryOp -> number .)
    SEMICOLON       reduce using rule 66 (binaryOp -> number .)
    WHILE           reduce using rule 66 (binaryOp -> number .)
    ELSE            reduce using rule 66 (binaryOp -> number .)
    RPAREN          reduce using rule 66 (binaryOp -> number .)
    COMMA           reduce using rule 66 (binaryOp -> number .)
    RCURLY          reduce using rule 66 (binaryOp -> number .)


state 22

    (38) expression -> binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    RPAREN          reduce using rule 38 (expression -> binaryOp .)
    $end            reduce using rule 38 (expression -> binaryOp .)
    SEMICOLON       reduce using rule 38 (expression -> binaryOp .)
    WHILE           reduce using rule 38 (expression -> binaryOp .)
    ELSE            reduce using rule 38 (expression -> binaryOp .)
    COMMA           reduce using rule 38 (expression -> binaryOp .)
    RCURLY          reduce using rule 38 (expression -> binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    AND             shift and go to state 64
    OR              shift and go to state 67
    LESSTHAN        shift and go to state 50
    LESSEQUALTHAN   shift and go to state 65
    GREATERTHAN     shift and go to state 63
    GREATEREQUALTHAN shift and go to state 58
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70


state 23

    (64) binaryOp -> TRUE .

    PLUS            reduce using rule 64 (binaryOp -> TRUE .)
    MINUS           reduce using rule 64 (binaryOp -> TRUE .)
    TIMES           reduce using rule 64 (binaryOp -> TRUE .)
    DIVIDE          reduce using rule 64 (binaryOp -> TRUE .)
    MODULE          reduce using rule 64 (binaryOp -> TRUE .)
    AND             reduce using rule 64 (binaryOp -> TRUE .)
    OR              reduce using rule 64 (binaryOp -> TRUE .)
    LESSTHAN        reduce using rule 64 (binaryOp -> TRUE .)
    LESSEQUALTHAN   reduce using rule 64 (binaryOp -> TRUE .)
    GREATERTHAN     reduce using rule 64 (binaryOp -> TRUE .)
    GREATEREQUALTHAN reduce using rule 64 (binaryOp -> TRUE .)
    EQUALS          reduce using rule 64 (binaryOp -> TRUE .)
    NOTEQUALS       reduce using rule 64 (binaryOp -> TRUE .)
    SETUNION        reduce using rule 64 (binaryOp -> TRUE .)
    SETDIFF         reduce using rule 64 (binaryOp -> TRUE .)
    SETINTERSECT    reduce using rule 64 (binaryOp -> TRUE .)
    SETMAPPLUS      reduce using rule 64 (binaryOp -> TRUE .)
    SETMAPMINUS     reduce using rule 64 (binaryOp -> TRUE .)
    SETMAPTIMES     reduce using rule 64 (binaryOp -> TRUE .)
    SETMAPDIVIDE    reduce using rule 64 (binaryOp -> TRUE .)
    SETMAPMODULE    reduce using rule 64 (binaryOp -> TRUE .)
    BELONGSTO       reduce using rule 64 (binaryOp -> TRUE .)
    $end            reduce using rule 64 (binaryOp -> TRUE .)
    SEMICOLON       reduce using rule 64 (binaryOp -> TRUE .)
    WHILE           reduce using rule 64 (binaryOp -> TRUE .)
    ELSE            reduce using rule 64 (binaryOp -> TRUE .)
    RPAREN          reduce using rule 64 (binaryOp -> TRUE .)
    COMMA           reduce using rule 64 (binaryOp -> TRUE .)
    RCURLY          reduce using rule 64 (binaryOp -> TRUE .)


state 24

    (47) binaryOp -> MINUS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 71

state 25

    (68) number -> NUMBER .

    PLUS            reduce using rule 68 (number -> NUMBER .)
    MINUS           reduce using rule 68 (number -> NUMBER .)
    TIMES           reduce using rule 68 (number -> NUMBER .)
    DIVIDE          reduce using rule 68 (number -> NUMBER .)
    MODULE          reduce using rule 68 (number -> NUMBER .)
    AND             reduce using rule 68 (number -> NUMBER .)
    OR              reduce using rule 68 (number -> NUMBER .)
    LESSTHAN        reduce using rule 68 (number -> NUMBER .)
    LESSEQUALTHAN   reduce using rule 68 (number -> NUMBER .)
    GREATERTHAN     reduce using rule 68 (number -> NUMBER .)
    GREATEREQUALTHAN reduce using rule 68 (number -> NUMBER .)
    EQUALS          reduce using rule 68 (number -> NUMBER .)
    NOTEQUALS       reduce using rule 68 (number -> NUMBER .)
    SETUNION        reduce using rule 68 (number -> NUMBER .)
    SETDIFF         reduce using rule 68 (number -> NUMBER .)
    SETINTERSECT    reduce using rule 68 (number -> NUMBER .)
    SETMAPPLUS      reduce using rule 68 (number -> NUMBER .)
    SETMAPMINUS     reduce using rule 68 (number -> NUMBER .)
    SETMAPTIMES     reduce using rule 68 (number -> NUMBER .)
    SETMAPDIVIDE    reduce using rule 68 (number -> NUMBER .)
    SETMAPMODULE    reduce using rule 68 (number -> NUMBER .)
    BELONGSTO       reduce using rule 68 (number -> NUMBER .)
    $end            reduce using rule 68 (number -> NUMBER .)
    SEMICOLON       reduce using rule 68 (number -> NUMBER .)
    WHILE           reduce using rule 68 (number -> NUMBER .)
    ELSE            reduce using rule 68 (number -> NUMBER .)
    COMMA           reduce using rule 68 (number -> NUMBER .)
    RCURLY          reduce using rule 68 (number -> NUMBER .)
    RPAREN          reduce using rule 68 (number -> NUMBER .)


state 26

    (48) binaryOp -> LPAREN . binaryOp RPAREN
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 72

state 27

    (65) binaryOp -> FALSE .

    PLUS            reduce using rule 65 (binaryOp -> FALSE .)
    MINUS           reduce using rule 65 (binaryOp -> FALSE .)
    TIMES           reduce using rule 65 (binaryOp -> FALSE .)
    DIVIDE          reduce using rule 65 (binaryOp -> FALSE .)
    MODULE          reduce using rule 65 (binaryOp -> FALSE .)
    AND             reduce using rule 65 (binaryOp -> FALSE .)
    OR              reduce using rule 65 (binaryOp -> FALSE .)
    LESSTHAN        reduce using rule 65 (binaryOp -> FALSE .)
    LESSEQUALTHAN   reduce using rule 65 (binaryOp -> FALSE .)
    GREATERTHAN     reduce using rule 65 (binaryOp -> FALSE .)
    GREATEREQUALTHAN reduce using rule 65 (binaryOp -> FALSE .)
    EQUALS          reduce using rule 65 (binaryOp -> FALSE .)
    NOTEQUALS       reduce using rule 65 (binaryOp -> FALSE .)
    SETUNION        reduce using rule 65 (binaryOp -> FALSE .)
    SETDIFF         reduce using rule 65 (binaryOp -> FALSE .)
    SETINTERSECT    reduce using rule 65 (binaryOp -> FALSE .)
    SETMAPPLUS      reduce using rule 65 (binaryOp -> FALSE .)
    SETMAPMINUS     reduce using rule 65 (binaryOp -> FALSE .)
    SETMAPTIMES     reduce using rule 65 (binaryOp -> FALSE .)
    SETMAPDIVIDE    reduce using rule 65 (binaryOp -> FALSE .)
    SETMAPMODULE    reduce using rule 65 (binaryOp -> FALSE .)
    BELONGSTO       reduce using rule 65 (binaryOp -> FALSE .)
    $end            reduce using rule 65 (binaryOp -> FALSE .)
    SEMICOLON       reduce using rule 65 (binaryOp -> FALSE .)
    WHILE           reduce using rule 65 (binaryOp -> FALSE .)
    ELSE            reduce using rule 65 (binaryOp -> FALSE .)
    RPAREN          reduce using rule 65 (binaryOp -> FALSE .)
    COMMA           reduce using rule 65 (binaryOp -> FALSE .)
    RCURLY          reduce using rule 65 (binaryOp -> FALSE .)


state 28

    (67) binaryOp -> IDENTIFIER .

    PLUS            reduce using rule 67 (binaryOp -> IDENTIFIER .)
    MINUS           reduce using rule 67 (binaryOp -> IDENTIFIER .)
    TIMES           reduce using rule 67 (binaryOp -> IDENTIFIER .)
    DIVIDE          reduce using rule 67 (binaryOp -> IDENTIFIER .)
    MODULE          reduce using rule 67 (binaryOp -> IDENTIFIER .)
    AND             reduce using rule 67 (binaryOp -> IDENTIFIER .)
    OR              reduce using rule 67 (binaryOp -> IDENTIFIER .)
    LESSTHAN        reduce using rule 67 (binaryOp -> IDENTIFIER .)
    LESSEQUALTHAN   reduce using rule 67 (binaryOp -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 67 (binaryOp -> IDENTIFIER .)
    GREATEREQUALTHAN reduce using rule 67 (binaryOp -> IDENTIFIER .)
    EQUALS          reduce using rule 67 (binaryOp -> IDENTIFIER .)
    NOTEQUALS       reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETUNION        reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETDIFF         reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETINTERSECT    reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETMAPPLUS      reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETMAPMINUS     reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETMAPTIMES     reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETMAPDIVIDE    reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SETMAPMODULE    reduce using rule 67 (binaryOp -> IDENTIFIER .)
    BELONGSTO       reduce using rule 67 (binaryOp -> IDENTIFIER .)
    $end            reduce using rule 67 (binaryOp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 67 (binaryOp -> IDENTIFIER .)
    WHILE           reduce using rule 67 (binaryOp -> IDENTIFIER .)
    ELSE            reduce using rule 67 (binaryOp -> IDENTIFIER .)
    RPAREN          reduce using rule 67 (binaryOp -> IDENTIFIER .)
    COMMA           reduce using rule 67 (binaryOp -> IDENTIFIER .)
    RCURLY          reduce using rule 67 (binaryOp -> IDENTIFIER .)


state 29

    (46) binaryOp -> NOT . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 73

state 30

    (31) scanInst -> SCAN expression .

    SEMICOLON       reduce using rule 31 (scanInst -> SCAN expression .)
    WHILE           reduce using rule 31 (scanInst -> SCAN expression .)
    $end            reduce using rule 31 (scanInst -> SCAN expression .)
    ELSE            reduce using rule 31 (scanInst -> SCAN expression .)


state 31

    (2) program -> PROGRAM LCURLY RCURLY .

    $end            reduce using rule 2 (program -> PROGRAM LCURLY RCURLY .)


state 32

    (12) instructionBlock -> instruction . SEMICOLON
    (13) instructionBlock -> instruction . SEMICOLON instructionBlock

    SEMICOLON       shift and go to state 74


state 33

    (3) instructionType -> LCURLY instructionBlock . RCURLY SEMICOLON

    RCURLY          shift and go to state 75


state 34

    (29) whileInst -> WHILE LPAREN . expression RPAREN DO instructionType
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    expression                     shift and go to state 76
    number                         shift and go to state 21
    binaryOp                       shift and go to state 22

state 35

    (34) printOutput -> PRINT outputType .

    ELSE            reduce using rule 34 (printOutput -> PRINT outputType .)
    $end            reduce using rule 34 (printOutput -> PRINT outputType .)
    SEMICOLON       reduce using rule 34 (printOutput -> PRINT outputType .)
    WHILE           reduce using rule 34 (printOutput -> PRINT outputType .)


state 36

    (36) outputType -> STRING .

    $end            reduce using rule 36 (outputType -> STRING .)
    SEMICOLON       reduce using rule 36 (outputType -> STRING .)
    WHILE           reduce using rule 36 (outputType -> STRING .)
    ELSE            reduce using rule 36 (outputType -> STRING .)


state 37

    (37) outputType -> expression .

    $end            reduce using rule 37 (outputType -> expression .)
    SEMICOLON       reduce using rule 37 (outputType -> expression .)
    WHILE           reduce using rule 37 (outputType -> expression .)
    ELSE            reduce using rule 37 (outputType -> expression .)


state 38

    (35) printOutput -> PRINTLN outputType .

    ELSE            reduce using rule 35 (printOutput -> PRINTLN outputType .)
    $end            reduce using rule 35 (printOutput -> PRINTLN outputType .)
    SEMICOLON       reduce using rule 35 (printOutput -> PRINTLN outputType .)
    WHILE           reduce using rule 35 (printOutput -> PRINTLN outputType .)


state 39

    (15) instruction -> IDENTIFIER ASSIGN . expression
    (16) instruction -> IDENTIFIER ASSIGN . LCURLY set RCURLY
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    LCURLY          shift and go to state 77
    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    expression                     shift and go to state 78
    number                         shift and go to state 21
    binaryOp                       shift and go to state 22

state 40

    (3) instructionType -> LCURLY . instructionBlock RCURLY SEMICOLON
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instructionBlock               shift and go to state 33
    scanInst                       shift and go to state 7
    instruction                    shift and go to state 32
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 41

    (30) repeatInst -> REPEAT instructionType . whileInst
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType

    WHILE           shift and go to state 6

    whileInst                      shift and go to state 79

state 42

    (27) forInst -> FOR IDENTIFIER . direction IDENTIFIER DO instructionType
    (28) forInst -> FOR IDENTIFIER . direction LCURLY IDENTIFIER RCURLY DO instructionType
    (32) direction -> . MIN
    (33) direction -> . MAX

    MIN             shift and go to state 82
    MAX             shift and go to state 81

    direction                      shift and go to state 80

state 43

    (25) ifInst -> IF LPAREN . expression RPAREN instructionType
    (26) ifInst -> IF LPAREN . expression RPAREN instructionType ELSE instructionType
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    expression                     shift and go to state 83
    number                         shift and go to state 21
    binaryOp                       shift and go to state 22

state 44

    (9) types -> SET .

    IDENTIFIER      reduce using rule 9 (types -> SET .)


state 45

    (7) types -> INT .

    IDENTIFIER      reduce using rule 7 (types -> INT .)


state 46

    (8) types -> BOOL .

    IDENTIFIER      reduce using rule 8 (types -> BOOL .)


state 47

    (5) declarationBlock -> types . id SEMICOLON
    (6) declarationBlock -> types . id SEMICOLON declarationBlock
    (10) id -> . IDENTIFIER
    (11) id -> . IDENTIFIER COMMA id

    IDENTIFIER      shift and go to state 84

    id                             shift and go to state 85

state 48

    (14) instruction -> USING declarationBlock . IN instructionBlock

    IN              shift and go to state 86


state 49

    (54) binaryOp -> binaryOp NOTEQUALS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 87

state 50

    (49) binaryOp -> binaryOp LESSTHAN . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 88

state 51

    (62) binaryOp -> binaryOp SETMAPMODULE . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 89

state 52

    (40) binaryOp -> binaryOp MINUS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 90

state 53

    (55) binaryOp -> binaryOp SETUNION . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 91

state 54

    (60) binaryOp -> binaryOp SETMAPTIMES . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 92

state 55

    (57) binaryOp -> binaryOp SETINTERSECT . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 93

state 56

    (39) binaryOp -> binaryOp PLUS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 94

state 57

    (56) binaryOp -> binaryOp SETDIFF . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 95

state 58

    (52) binaryOp -> binaryOp GREATEREQUALTHAN . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 96

state 59

    (42) binaryOp -> binaryOp DIVIDE . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 97

state 60

    (53) binaryOp -> binaryOp EQUALS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 98

state 61

    (43) binaryOp -> binaryOp MODULE . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 99

state 62

    (41) binaryOp -> binaryOp TIMES . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 100

state 63

    (51) binaryOp -> binaryOp GREATERTHAN . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 101

state 64

    (44) binaryOp -> binaryOp AND . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 102

state 65

    (50) binaryOp -> binaryOp LESSEQUALTHAN . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 103

state 66

    (58) binaryOp -> binaryOp SETMAPPLUS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 104

state 67

    (45) binaryOp -> binaryOp OR . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 105

state 68

    (61) binaryOp -> binaryOp SETMAPDIVIDE . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 106

state 69

    (59) binaryOp -> binaryOp SETMAPMINUS . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 107

state 70

    (63) binaryOp -> binaryOp BELONGSTO . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    number                         shift and go to state 21
    binaryOp                       shift and go to state 108

state 71

    (47) binaryOp -> MINUS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    MINUS           reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    AND             reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    OR              reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    LESSTHAN        reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    GREATERTHAN     reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    EQUALS          reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    NOTEQUALS       reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    $end            reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    SEMICOLON       reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    WHILE           reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    ELSE            reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    RPAREN          reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    COMMA           reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    RCURLY          reduce using rule 47 (binaryOp -> MINUS binaryOp .)
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! TIMES           [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! MODULE          [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETUNION        [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 47 (binaryOp -> MINUS binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 72

    (48) binaryOp -> LPAREN binaryOp . RPAREN
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    RPAREN          shift and go to state 109
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    AND             shift and go to state 64
    OR              shift and go to state 67
    LESSTHAN        shift and go to state 50
    LESSEQUALTHAN   shift and go to state 65
    GREATERTHAN     shift and go to state 63
    GREATEREQUALTHAN shift and go to state 58
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70


state 73

    (46) binaryOp -> NOT binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 46 (binaryOp -> NOT binaryOp .)
    OR              reduce using rule 46 (binaryOp -> NOT binaryOp .)
    $end            reduce using rule 46 (binaryOp -> NOT binaryOp .)
    SEMICOLON       reduce using rule 46 (binaryOp -> NOT binaryOp .)
    WHILE           reduce using rule 46 (binaryOp -> NOT binaryOp .)
    ELSE            reduce using rule 46 (binaryOp -> NOT binaryOp .)
    RPAREN          reduce using rule 46 (binaryOp -> NOT binaryOp .)
    COMMA           reduce using rule 46 (binaryOp -> NOT binaryOp .)
    RCURLY          reduce using rule 46 (binaryOp -> NOT binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    LESSTHAN        shift and go to state 50
    LESSEQUALTHAN   shift and go to state 65
    GREATERTHAN     shift and go to state 63
    GREATEREQUALTHAN shift and go to state 58
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! MINUS           [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! TIMES           [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! DIVIDE          [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! MODULE          [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! LESSTHAN        [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! LESSEQUALTHAN   [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! GREATERTHAN     [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! GREATEREQUALTHAN [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! EQUALS          [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETUNION        [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETDIFF         [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 46 (binaryOp -> NOT binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]


state 74

    (12) instructionBlock -> instruction SEMICOLON .
    (13) instructionBlock -> instruction SEMICOLON . instructionBlock
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

  ! shift/reduce conflict for WHILE resolved as shift
    RCURLY          reduce using rule 12 (instructionBlock -> instruction SEMICOLON .)
    $end            reduce using rule 12 (instructionBlock -> instruction SEMICOLON .)
    SEMICOLON       reduce using rule 12 (instructionBlock -> instruction SEMICOLON .)
    ELSE            reduce using rule 12 (instructionBlock -> instruction SEMICOLON .)
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

  ! WHILE           [ reduce using rule 12 (instructionBlock -> instruction SEMICOLON .) ]

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instruction                    shift and go to state 32
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13
    instructionBlock               shift and go to state 110

state 75

    (3) instructionType -> LCURLY instructionBlock RCURLY . SEMICOLON

    SEMICOLON       shift and go to state 111


state 76

    (29) whileInst -> WHILE LPAREN expression . RPAREN DO instructionType

    RPAREN          shift and go to state 112


state 77

    (16) instruction -> IDENTIFIER ASSIGN LCURLY . set RCURLY
    (23) set -> . expression COMMA set
    (24) set -> . expression
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    set                            shift and go to state 113
    expression                     shift and go to state 114
    number                         shift and go to state 21
    binaryOp                       shift and go to state 22

state 78

    (15) instruction -> IDENTIFIER ASSIGN expression .

    WHILE           reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)
    ELSE            reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)


state 79

    (30) repeatInst -> REPEAT instructionType whileInst .

    ELSE            reduce using rule 30 (repeatInst -> REPEAT instructionType whileInst .)
    $end            reduce using rule 30 (repeatInst -> REPEAT instructionType whileInst .)
    SEMICOLON       reduce using rule 30 (repeatInst -> REPEAT instructionType whileInst .)
    WHILE           reduce using rule 30 (repeatInst -> REPEAT instructionType whileInst .)


state 80

    (27) forInst -> FOR IDENTIFIER direction . IDENTIFIER DO instructionType
    (28) forInst -> FOR IDENTIFIER direction . LCURLY IDENTIFIER RCURLY DO instructionType

    IDENTIFIER      shift and go to state 116
    LCURLY          shift and go to state 115


state 81

    (33) direction -> MAX .

    IDENTIFIER      reduce using rule 33 (direction -> MAX .)
    LCURLY          reduce using rule 33 (direction -> MAX .)


state 82

    (32) direction -> MIN .

    IDENTIFIER      reduce using rule 32 (direction -> MIN .)
    LCURLY          reduce using rule 32 (direction -> MIN .)


state 83

    (25) ifInst -> IF LPAREN expression . RPAREN instructionType
    (26) ifInst -> IF LPAREN expression . RPAREN instructionType ELSE instructionType

    RPAREN          shift and go to state 117


state 84

    (10) id -> IDENTIFIER .
    (11) id -> IDENTIFIER . COMMA id

    SEMICOLON       reduce using rule 10 (id -> IDENTIFIER .)
    COMMA           shift and go to state 118


state 85

    (5) declarationBlock -> types id . SEMICOLON
    (6) declarationBlock -> types id . SEMICOLON declarationBlock

    SEMICOLON       shift and go to state 119


state 86

    (14) instruction -> USING declarationBlock IN . instructionBlock
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instructionBlock               shift and go to state 120
    scanInst                       shift and go to state 7
    instruction                    shift and go to state 32
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 87

    (54) binaryOp -> binaryOp NOTEQUALS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    OR              reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    LESSTHAN        reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    LESSEQUALTHAN   reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    GREATERTHAN     reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    GREATEREQUALTHAN reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    EQUALS          reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    NOTEQUALS       reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    $end            reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    SEMICOLON       reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    WHILE           reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    ELSE            reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    RPAREN          reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    COMMA           reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    RCURLY          reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! MINUS           [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! TIMES           [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! MODULE          [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETUNION        [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 54 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 88

    (49) binaryOp -> binaryOp LESSTHAN binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    OR              reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    LESSTHAN        reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    GREATERTHAN     reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    $end            reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    SEMICOLON       reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    WHILE           reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    ELSE            reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    RPAREN          reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    COMMA           reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    RCURLY          reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 49 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]


state 89

    (62) binaryOp -> binaryOp SETMAPMODULE binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    MINUS           reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    TIMES           reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    DIVIDE          reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    MODULE          reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    AND             reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    OR              reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    LESSTHAN        reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    LESSEQUALTHAN   reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    GREATERTHAN     reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    GREATEREQUALTHAN reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    EQUALS          reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    NOTEQUALS       reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETUNION        reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETDIFF         reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETINTERSECT    reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPPLUS      reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPMINUS     reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPTIMES     reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPDIVIDE    reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPMODULE    reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    $end            reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SEMICOLON       reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    WHILE           reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    ELSE            reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    RPAREN          reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    COMMA           reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    RCURLY          reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    BELONGSTO       shift and go to state 70

  ! BELONGSTO       [ reduce using rule 62 (binaryOp -> binaryOp SETMAPMODULE binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]
  ! SETMAPPLUS      [ shift and go to state 66 ]
  ! SETMAPMINUS     [ shift and go to state 69 ]
  ! SETMAPTIMES     [ shift and go to state 54 ]
  ! SETMAPDIVIDE    [ shift and go to state 68 ]
  ! SETMAPMODULE    [ shift and go to state 51 ]


state 90

    (40) binaryOp -> binaryOp MINUS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    MINUS           reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    AND             reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    OR              reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    LESSTHAN        reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    GREATERTHAN     reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    EQUALS          reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    NOTEQUALS       reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    $end            reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    SEMICOLON       reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    WHILE           reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    ELSE            reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    RPAREN          reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    COMMA           reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    RCURLY          reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .)
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! TIMES           [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! MODULE          [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETUNION        [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 40 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 91

    (55) binaryOp -> binaryOp SETUNION binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    MINUS           reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    TIMES           reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    DIVIDE          reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    MODULE          reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    AND             reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    OR              reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    LESSTHAN        reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    LESSEQUALTHAN   reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    GREATERTHAN     reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    GREATEREQUALTHAN reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    EQUALS          reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    NOTEQUALS       reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    SETUNION        reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    SETDIFF         reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    $end            reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    SEMICOLON       reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    WHILE           reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    ELSE            reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    RPAREN          reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    COMMA           reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    RCURLY          reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .)
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETINTERSECT    [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 55 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]


state 92

    (60) binaryOp -> binaryOp SETMAPTIMES binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    MINUS           reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    TIMES           reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    DIVIDE          reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    MODULE          reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    AND             reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    OR              reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    LESSTHAN        reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    LESSEQUALTHAN   reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    GREATERTHAN     reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    GREATEREQUALTHAN reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    EQUALS          reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    NOTEQUALS       reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETUNION        reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETDIFF         reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETINTERSECT    reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPPLUS      reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPMINUS     reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPTIMES     reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPDIVIDE    reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPMODULE    reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    $end            reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SEMICOLON       reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    WHILE           reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    ELSE            reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    RPAREN          reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    COMMA           reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    RCURLY          reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    BELONGSTO       shift and go to state 70

  ! BELONGSTO       [ reduce using rule 60 (binaryOp -> binaryOp SETMAPTIMES binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]
  ! SETMAPPLUS      [ shift and go to state 66 ]
  ! SETMAPMINUS     [ shift and go to state 69 ]
  ! SETMAPTIMES     [ shift and go to state 54 ]
  ! SETMAPDIVIDE    [ shift and go to state 68 ]
  ! SETMAPMODULE    [ shift and go to state 51 ]


state 93

    (57) binaryOp -> binaryOp SETINTERSECT binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    MINUS           reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    TIMES           reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    DIVIDE          reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    MODULE          reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    AND             reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    OR              reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    LESSTHAN        reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    LESSEQUALTHAN   reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    GREATERTHAN     reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    GREATEREQUALTHAN reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    EQUALS          reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    NOTEQUALS       reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETUNION        reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETDIFF         reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETINTERSECT    reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    $end            reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SEMICOLON       reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    WHILE           reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    ELSE            reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    RPAREN          reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    COMMA           reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    RCURLY          reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETMAPPLUS      [ reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 57 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]


state 94

    (39) binaryOp -> binaryOp PLUS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    MINUS           reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    AND             reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    OR              reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    LESSTHAN        reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    GREATERTHAN     reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    EQUALS          reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    NOTEQUALS       reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    $end            reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    SEMICOLON       reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    WHILE           reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    ELSE            reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    RPAREN          reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    COMMA           reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    RCURLY          reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .)
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! TIMES           [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! MODULE          [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETUNION        [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 39 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 95

    (56) binaryOp -> binaryOp SETDIFF binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    MINUS           reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    TIMES           reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    DIVIDE          reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    MODULE          reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    AND             reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    OR              reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    LESSTHAN        reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    LESSEQUALTHAN   reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    GREATERTHAN     reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    GREATEREQUALTHAN reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    EQUALS          reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    NOTEQUALS       reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SETUNION        reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SETDIFF         reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    $end            reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SEMICOLON       reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    WHILE           reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    ELSE            reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    RPAREN          reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    COMMA           reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    RCURLY          reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETINTERSECT    [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 56 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]


state 96

    (52) binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    OR              reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    LESSTHAN        reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    GREATERTHAN     reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    $end            reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    SEMICOLON       reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    WHILE           reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    ELSE            reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    RPAREN          reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    COMMA           reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    RCURLY          reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 52 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]


state 97

    (42) binaryOp -> binaryOp DIVIDE binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    MINUS           reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    TIMES           reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    DIVIDE          reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    MODULE          reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    AND             reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    OR              reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    LESSTHAN        reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    LESSEQUALTHAN   reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    GREATERTHAN     reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    GREATEREQUALTHAN reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    EQUALS          reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    NOTEQUALS       reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    $end            reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    SEMICOLON       reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    WHILE           reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    ELSE            reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    RPAREN          reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    COMMA           reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    RCURLY          reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .)
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETUNION        [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETDIFF         [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 42 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 98

    (53) binaryOp -> binaryOp EQUALS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    OR              reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    LESSTHAN        reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    LESSEQUALTHAN   reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    GREATERTHAN     reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    GREATEREQUALTHAN reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    EQUALS          reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    NOTEQUALS       reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    $end            reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    SEMICOLON       reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    WHILE           reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    ELSE            reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    RPAREN          reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    COMMA           reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    RCURLY          reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! MINUS           [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! TIMES           [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! MODULE          [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETUNION        [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 53 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 99

    (43) binaryOp -> binaryOp MODULE binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    MINUS           reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    TIMES           reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    DIVIDE          reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    MODULE          reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    AND             reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    OR              reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    LESSTHAN        reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    LESSEQUALTHAN   reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    GREATERTHAN     reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    GREATEREQUALTHAN reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    EQUALS          reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    NOTEQUALS       reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    $end            reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    SEMICOLON       reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    WHILE           reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    ELSE            reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    RPAREN          reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    COMMA           reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    RCURLY          reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .)
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETUNION        [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETDIFF         [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 43 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 100

    (41) binaryOp -> binaryOp TIMES binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    MINUS           reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    TIMES           reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    DIVIDE          reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    MODULE          reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    AND             reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    OR              reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    LESSTHAN        reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    LESSEQUALTHAN   reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    GREATERTHAN     reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    GREATEREQUALTHAN reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    EQUALS          reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    NOTEQUALS       reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    $end            reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    SEMICOLON       reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    WHILE           reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    ELSE            reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    RPAREN          reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    COMMA           reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    RCURLY          reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .)
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETUNION        [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETDIFF         [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 41 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]


state 101

    (51) binaryOp -> binaryOp GREATERTHAN binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    OR              reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    LESSTHAN        reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    GREATERTHAN     reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    $end            reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    SEMICOLON       reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    WHILE           reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    ELSE            reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    RPAREN          reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    COMMA           reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    RCURLY          reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 51 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]


state 102

    (44) binaryOp -> binaryOp AND binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    OR              reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    $end            reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    SEMICOLON       reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    WHILE           reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    ELSE            reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    RPAREN          reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    COMMA           reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    RCURLY          reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    LESSTHAN        shift and go to state 50
    LESSEQUALTHAN   shift and go to state 65
    GREATERTHAN     shift and go to state 63
    GREATEREQUALTHAN shift and go to state 58
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! MINUS           [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! TIMES           [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! DIVIDE          [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! MODULE          [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! LESSTHAN        [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! LESSEQUALTHAN   [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! GREATERTHAN     [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! GREATEREQUALTHAN [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! EQUALS          [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETUNION        [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETDIFF         [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 44 (binaryOp -> binaryOp AND binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]


state 103

    (50) binaryOp -> binaryOp LESSEQUALTHAN binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    OR              reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    LESSTHAN        reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    GREATERTHAN     reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    $end            reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    SEMICOLON       reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    WHILE           reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    ELSE            reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    RPAREN          reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    COMMA           reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    RCURLY          reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 50 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]


state 104

    (58) binaryOp -> binaryOp SETMAPPLUS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    MINUS           reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    TIMES           reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    DIVIDE          reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    MODULE          reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    AND             reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    OR              reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    LESSTHAN        reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    GREATERTHAN     reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    EQUALS          reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    NOTEQUALS       reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETUNION        reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETDIFF         reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETINTERSECT    reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETMAPPLUS      reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETMAPMINUS     reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    $end            reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SEMICOLON       reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    WHILE           reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    ELSE            reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    RPAREN          reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    COMMA           reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    RCURLY          reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETMAPTIMES     [ reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 58 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]
  ! SETMAPPLUS      [ shift and go to state 66 ]
  ! SETMAPMINUS     [ shift and go to state 69 ]


state 105

    (45) binaryOp -> binaryOp OR binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    OR              reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    $end            reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    SEMICOLON       reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    WHILE           reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    ELSE            reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    RPAREN          reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    COMMA           reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    RCURLY          reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 52
    TIMES           shift and go to state 62
    DIVIDE          shift and go to state 59
    MODULE          shift and go to state 61
    AND             shift and go to state 64
    LESSTHAN        shift and go to state 50
    LESSEQUALTHAN   shift and go to state 65
    GREATERTHAN     shift and go to state 63
    GREATEREQUALTHAN shift and go to state 58
    EQUALS          shift and go to state 60
    NOTEQUALS       shift and go to state 49
    SETUNION        shift and go to state 53
    SETDIFF         shift and go to state 57
    SETINTERSECT    shift and go to state 55
    SETMAPPLUS      shift and go to state 66
    SETMAPMINUS     shift and go to state 69
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! PLUS            [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! MINUS           [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! TIMES           [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! DIVIDE          [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! MODULE          [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! AND             [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! LESSTHAN        [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! LESSEQUALTHAN   [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! GREATERTHAN     [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! GREATEREQUALTHAN [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! EQUALS          [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETUNION        [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETDIFF         [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 45 (binaryOp -> binaryOp OR binaryOp .) ]
  ! OR              [ shift and go to state 67 ]


state 106

    (61) binaryOp -> binaryOp SETMAPDIVIDE binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    MINUS           reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    TIMES           reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    DIVIDE          reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    MODULE          reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    AND             reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    OR              reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    LESSTHAN        reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    LESSEQUALTHAN   reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    GREATERTHAN     reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    GREATEREQUALTHAN reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    EQUALS          reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    NOTEQUALS       reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETUNION        reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETDIFF         reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETINTERSECT    reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPPLUS      reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPMINUS     reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPTIMES     reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPDIVIDE    reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPMODULE    reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    $end            reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SEMICOLON       reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    WHILE           reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    ELSE            reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    RPAREN          reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    COMMA           reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    RCURLY          reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    BELONGSTO       shift and go to state 70

  ! BELONGSTO       [ reduce using rule 61 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]
  ! SETMAPPLUS      [ shift and go to state 66 ]
  ! SETMAPMINUS     [ shift and go to state 69 ]
  ! SETMAPTIMES     [ shift and go to state 54 ]
  ! SETMAPDIVIDE    [ shift and go to state 68 ]
  ! SETMAPMODULE    [ shift and go to state 51 ]


state 107

    (59) binaryOp -> binaryOp SETMAPMINUS binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    MINUS           reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    TIMES           reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    DIVIDE          reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    MODULE          reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    AND             reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    OR              reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    LESSTHAN        reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    GREATERTHAN     reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    EQUALS          reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    NOTEQUALS       reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETUNION        reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETDIFF         reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETINTERSECT    reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETMAPPLUS      reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETMAPMINUS     reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    $end            reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SEMICOLON       reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    WHILE           reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    ELSE            reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    RPAREN          reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    COMMA           reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    RCURLY          reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETMAPTIMES     shift and go to state 54
    SETMAPDIVIDE    shift and go to state 68
    SETMAPMODULE    shift and go to state 51
    BELONGSTO       shift and go to state 70

  ! SETMAPTIMES     [ reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 59 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]
  ! SETMAPPLUS      [ shift and go to state 66 ]
  ! SETMAPMINUS     [ shift and go to state 69 ]


state 108

    (63) binaryOp -> binaryOp BELONGSTO binaryOp .
    (39) binaryOp -> binaryOp . PLUS binaryOp
    (40) binaryOp -> binaryOp . MINUS binaryOp
    (41) binaryOp -> binaryOp . TIMES binaryOp
    (42) binaryOp -> binaryOp . DIVIDE binaryOp
    (43) binaryOp -> binaryOp . MODULE binaryOp
    (44) binaryOp -> binaryOp . AND binaryOp
    (45) binaryOp -> binaryOp . OR binaryOp
    (49) binaryOp -> binaryOp . LESSTHAN binaryOp
    (50) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (51) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (52) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (53) binaryOp -> binaryOp . EQUALS binaryOp
    (54) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (55) binaryOp -> binaryOp . SETUNION binaryOp
    (56) binaryOp -> binaryOp . SETDIFF binaryOp
    (57) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (58) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (59) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (60) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (61) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (62) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (63) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    MINUS           reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    TIMES           reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    DIVIDE          reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    MODULE          reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    AND             reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    OR              reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    LESSTHAN        reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    LESSEQUALTHAN   reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    GREATERTHAN     reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    GREATEREQUALTHAN reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    EQUALS          reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    NOTEQUALS       reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETUNION        reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETDIFF         reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETINTERSECT    reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPPLUS      reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPMINUS     reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPTIMES     reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPDIVIDE    reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPMODULE    reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    BELONGSTO       reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    $end            reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SEMICOLON       reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    WHILE           reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    ELSE            reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    RPAREN          reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    COMMA           reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    RCURLY          reduce using rule 63 (binaryOp -> binaryOp BELONGSTO binaryOp .)

  ! PLUS            [ shift and go to state 56 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 59 ]
  ! MODULE          [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 67 ]
  ! LESSTHAN        [ shift and go to state 50 ]
  ! LESSEQUALTHAN   [ shift and go to state 65 ]
  ! GREATERTHAN     [ shift and go to state 63 ]
  ! GREATEREQUALTHAN [ shift and go to state 58 ]
  ! EQUALS          [ shift and go to state 60 ]
  ! NOTEQUALS       [ shift and go to state 49 ]
  ! SETUNION        [ shift and go to state 53 ]
  ! SETDIFF         [ shift and go to state 57 ]
  ! SETINTERSECT    [ shift and go to state 55 ]
  ! SETMAPPLUS      [ shift and go to state 66 ]
  ! SETMAPMINUS     [ shift and go to state 69 ]
  ! SETMAPTIMES     [ shift and go to state 54 ]
  ! SETMAPDIVIDE    [ shift and go to state 68 ]
  ! SETMAPMODULE    [ shift and go to state 51 ]
  ! BELONGSTO       [ shift and go to state 70 ]


state 109

    (48) binaryOp -> LPAREN binaryOp RPAREN .

    PLUS            reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    MINUS           reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    TIMES           reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    DIVIDE          reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    MODULE          reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    AND             reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    OR              reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    LESSTHAN        reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    LESSEQUALTHAN   reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    GREATERTHAN     reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    GREATEREQUALTHAN reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    EQUALS          reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    NOTEQUALS       reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETUNION        reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETDIFF         reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETINTERSECT    reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPPLUS      reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPMINUS     reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPTIMES     reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPDIVIDE    reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPMODULE    reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    BELONGSTO       reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    $end            reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    SEMICOLON       reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    WHILE           reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    ELSE            reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    RPAREN          reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    COMMA           reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)
    RCURLY          reduce using rule 48 (binaryOp -> LPAREN binaryOp RPAREN .)


state 110

    (13) instructionBlock -> instruction SEMICOLON instructionBlock .

    RCURLY          reduce using rule 13 (instructionBlock -> instruction SEMICOLON instructionBlock .)
    $end            reduce using rule 13 (instructionBlock -> instruction SEMICOLON instructionBlock .)
    SEMICOLON       reduce using rule 13 (instructionBlock -> instruction SEMICOLON instructionBlock .)
    WHILE           reduce using rule 13 (instructionBlock -> instruction SEMICOLON instructionBlock .)
    ELSE            reduce using rule 13 (instructionBlock -> instruction SEMICOLON instructionBlock .)


state 111

    (3) instructionType -> LCURLY instructionBlock RCURLY SEMICOLON .

    ELSE            reduce using rule 3 (instructionType -> LCURLY instructionBlock RCURLY SEMICOLON .)
    $end            reduce using rule 3 (instructionType -> LCURLY instructionBlock RCURLY SEMICOLON .)
    SEMICOLON       reduce using rule 3 (instructionType -> LCURLY instructionBlock RCURLY SEMICOLON .)
    WHILE           reduce using rule 3 (instructionType -> LCURLY instructionBlock RCURLY SEMICOLON .)


state 112

    (29) whileInst -> WHILE LPAREN expression RPAREN . DO instructionType

    DO              shift and go to state 121


state 113

    (16) instruction -> IDENTIFIER ASSIGN LCURLY set . RCURLY

    RCURLY          shift and go to state 122


state 114

    (23) set -> expression . COMMA set
    (24) set -> expression .

    COMMA           shift and go to state 123
    RCURLY          reduce using rule 24 (set -> expression .)


state 115

    (28) forInst -> FOR IDENTIFIER direction LCURLY . IDENTIFIER RCURLY DO instructionType

    IDENTIFIER      shift and go to state 124


state 116

    (27) forInst -> FOR IDENTIFIER direction IDENTIFIER . DO instructionType

    DO              shift and go to state 125


state 117

    (25) ifInst -> IF LPAREN expression RPAREN . instructionType
    (26) ifInst -> IF LPAREN expression RPAREN . instructionType ELSE instructionType
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 40
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instruction                    shift and go to state 19
    scanInst                       shift and go to state 7
    instructionType                shift and go to state 126
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 118

    (11) id -> IDENTIFIER COMMA . id
    (10) id -> . IDENTIFIER
    (11) id -> . IDENTIFIER COMMA id

    IDENTIFIER      shift and go to state 84

    id                             shift and go to state 127

state 119

    (5) declarationBlock -> types id SEMICOLON .
    (6) declarationBlock -> types id SEMICOLON . declarationBlock
    (5) declarationBlock -> . types id SEMICOLON
    (6) declarationBlock -> . types id SEMICOLON declarationBlock
    (7) types -> . INT
    (8) types -> . BOOL
    (9) types -> . SET

    IN              reduce using rule 5 (declarationBlock -> types id SEMICOLON .)
    INT             shift and go to state 45
    BOOL            shift and go to state 46
    SET             shift and go to state 44

    types                          shift and go to state 47
    declarationBlock               shift and go to state 128

state 120

    (14) instruction -> USING declarationBlock IN instructionBlock .

    WHILE           reduce using rule 14 (instruction -> USING declarationBlock IN instructionBlock .)
    ELSE            reduce using rule 14 (instruction -> USING declarationBlock IN instructionBlock .)
    $end            reduce using rule 14 (instruction -> USING declarationBlock IN instructionBlock .)
    SEMICOLON       reduce using rule 14 (instruction -> USING declarationBlock IN instructionBlock .)


state 121

    (29) whileInst -> WHILE LPAREN expression RPAREN DO . instructionType
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 40
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instruction                    shift and go to state 19
    scanInst                       shift and go to state 7
    instructionType                shift and go to state 129
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 122

    (16) instruction -> IDENTIFIER ASSIGN LCURLY set RCURLY .

    WHILE           reduce using rule 16 (instruction -> IDENTIFIER ASSIGN LCURLY set RCURLY .)
    ELSE            reduce using rule 16 (instruction -> IDENTIFIER ASSIGN LCURLY set RCURLY .)
    $end            reduce using rule 16 (instruction -> IDENTIFIER ASSIGN LCURLY set RCURLY .)
    SEMICOLON       reduce using rule 16 (instruction -> IDENTIFIER ASSIGN LCURLY set RCURLY .)


state 123

    (23) set -> expression COMMA . set
    (23) set -> . expression COMMA set
    (24) set -> . expression
    (38) expression -> . binaryOp
    (39) binaryOp -> . binaryOp PLUS binaryOp
    (40) binaryOp -> . binaryOp MINUS binaryOp
    (41) binaryOp -> . binaryOp TIMES binaryOp
    (42) binaryOp -> . binaryOp DIVIDE binaryOp
    (43) binaryOp -> . binaryOp MODULE binaryOp
    (44) binaryOp -> . binaryOp AND binaryOp
    (45) binaryOp -> . binaryOp OR binaryOp
    (46) binaryOp -> . NOT binaryOp
    (47) binaryOp -> . MINUS binaryOp
    (48) binaryOp -> . LPAREN binaryOp RPAREN
    (49) binaryOp -> . binaryOp LESSTHAN binaryOp
    (50) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (51) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (52) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (53) binaryOp -> . binaryOp EQUALS binaryOp
    (54) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (55) binaryOp -> . binaryOp SETUNION binaryOp
    (56) binaryOp -> . binaryOp SETDIFF binaryOp
    (57) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (58) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (59) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (60) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (61) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (62) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (63) binaryOp -> . binaryOp BELONGSTO binaryOp
    (64) binaryOp -> . TRUE
    (65) binaryOp -> . FALSE
    (66) binaryOp -> . number
    (67) binaryOp -> . IDENTIFIER
    (68) number -> . NUMBER

    NOT             shift and go to state 29
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 26
    TRUE            shift and go to state 23
    FALSE           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    NUMBER          shift and go to state 25

    set                            shift and go to state 130
    expression                     shift and go to state 114
    number                         shift and go to state 21
    binaryOp                       shift and go to state 22

state 124

    (28) forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER . RCURLY DO instructionType

    RCURLY          shift and go to state 131


state 125

    (27) forInst -> FOR IDENTIFIER direction IDENTIFIER DO . instructionType
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 40
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    instruction                    shift and go to state 19
    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    scanInst                       shift and go to state 7
    instructionType                shift and go to state 132
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 126

    (25) ifInst -> IF LPAREN expression RPAREN instructionType .
    (26) ifInst -> IF LPAREN expression RPAREN instructionType . ELSE instructionType

  ! shift/reduce conflict for ELSE resolved as shift
    $end            reduce using rule 25 (ifInst -> IF LPAREN expression RPAREN instructionType .)
    SEMICOLON       reduce using rule 25 (ifInst -> IF LPAREN expression RPAREN instructionType .)
    WHILE           reduce using rule 25 (ifInst -> IF LPAREN expression RPAREN instructionType .)
    ELSE            shift and go to state 133

  ! ELSE            [ reduce using rule 25 (ifInst -> IF LPAREN expression RPAREN instructionType .) ]


state 127

    (11) id -> IDENTIFIER COMMA id .

    SEMICOLON       reduce using rule 11 (id -> IDENTIFIER COMMA id .)


state 128

    (6) declarationBlock -> types id SEMICOLON declarationBlock .

    IN              reduce using rule 6 (declarationBlock -> types id SEMICOLON declarationBlock .)


state 129

    (29) whileInst -> WHILE LPAREN expression RPAREN DO instructionType .

    $end            reduce using rule 29 (whileInst -> WHILE LPAREN expression RPAREN DO instructionType .)
    ELSE            reduce using rule 29 (whileInst -> WHILE LPAREN expression RPAREN DO instructionType .)
    SEMICOLON       reduce using rule 29 (whileInst -> WHILE LPAREN expression RPAREN DO instructionType .)
    WHILE           reduce using rule 29 (whileInst -> WHILE LPAREN expression RPAREN DO instructionType .)


state 130

    (23) set -> expression COMMA set .

    RCURLY          reduce using rule 23 (set -> expression COMMA set .)


state 131

    (28) forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY . DO instructionType

    DO              shift and go to state 134


state 132

    (27) forInst -> FOR IDENTIFIER direction IDENTIFIER DO instructionType .

    $end            reduce using rule 27 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instructionType .)
    ELSE            reduce using rule 27 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instructionType .)
    SEMICOLON       reduce using rule 27 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instructionType .)
    WHILE           reduce using rule 27 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instructionType .)


state 133

    (26) ifInst -> IF LPAREN expression RPAREN instructionType ELSE . instructionType
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 40
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    instruction                    shift and go to state 19
    scanInst                       shift and go to state 7
    instructionType                shift and go to state 135
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 134

    (28) forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO . instructionType
    (3) instructionType -> . LCURLY instructionBlock RCURLY SEMICOLON
    (4) instructionType -> . instruction
    (14) instruction -> . USING declarationBlock IN instructionBlock
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN LCURLY set RCURLY
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (25) ifInst -> . IF LPAREN expression RPAREN instructionType
    (26) ifInst -> . IF LPAREN expression RPAREN instructionType ELSE instructionType
    (34) printOutput -> . PRINT outputType
    (35) printOutput -> . PRINTLN outputType
    (29) whileInst -> . WHILE LPAREN expression RPAREN DO instructionType
    (30) repeatInst -> . REPEAT instructionType whileInst
    (27) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instructionType
    (28) forInst -> . FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType
    (31) scanInst -> . SCAN expression

    LCURLY          shift and go to state 40
    USING           shift and go to state 20
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 18
    PRINT           shift and go to state 8
    PRINTLN         shift and go to state 11
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 14
    FOR             shift and go to state 16
    SCAN            shift and go to state 4

    instruction                    shift and go to state 19
    printOutput                    shift and go to state 15
    forInst                        shift and go to state 3
    scanInst                       shift and go to state 7
    instructionType                shift and go to state 136
    repeatInst                     shift and go to state 17
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 13

state 135

    (26) ifInst -> IF LPAREN expression RPAREN instructionType ELSE instructionType .

    ELSE            reduce using rule 26 (ifInst -> IF LPAREN expression RPAREN instructionType ELSE instructionType .)
    $end            reduce using rule 26 (ifInst -> IF LPAREN expression RPAREN instructionType ELSE instructionType .)
    SEMICOLON       reduce using rule 26 (ifInst -> IF LPAREN expression RPAREN instructionType ELSE instructionType .)
    WHILE           reduce using rule 26 (ifInst -> IF LPAREN expression RPAREN instructionType ELSE instructionType .)


state 136

    (28) forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType .

    $end            reduce using rule 28 (forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType .)
    ELSE            reduce using rule 28 (forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType .)
    SEMICOLON       reduce using rule 28 (forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType .)
    WHILE           reduce using rule 28 (forInst -> FOR IDENTIFIER direction LCURLY IDENTIFIER RCURLY DO instructionType .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for WHILE in state 74 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 126 resolved as shift
