Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    SETMINVALUE
    COMMENT
    SIMPLEQUOTE
    RDOUBLEQUOTE
    SETMAXVALUE
    SETSIZE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM instruction
Rule 2     declarationBlock -> types id SEMICOLON
Rule 3     declarationBlock -> types id SEMICOLON declarationBlock
Rule 4     types -> INT
Rule 5     types -> BOOL
Rule 6     types -> SET
Rule 7     id -> IDENTIFIER
Rule 8     id -> IDENTIFIER COMMA id
Rule 9     block -> LCURLY usingInInst RCURLY
Rule 10    block -> LCURLY instructionBlock RCURLY
Rule 11    empty -> <empty>
Rule 12    instructionBlock -> instruction SEMICOLON
Rule 13    instructionBlock -> instruction SEMICOLON instructionBlock
Rule 14    instructionBlock -> empty
Rule 15    instruction -> IDENTIFIER ASSIGN expression
Rule 16    instruction -> IDENTIFIER ASSIGN set
Rule 17    instruction -> ifInst
Rule 18    instruction -> printOutput
Rule 19    instruction -> whileInst
Rule 20    instruction -> repeatInst
Rule 21    instruction -> forInst
Rule 22    instruction -> scanInst
Rule 23    instruction -> block
Rule 24    usingInInst -> USING declarationBlock IN instructionBlock
Rule 25    set -> LCURLY setNumbers RCURLY
Rule 26    setNumbers -> expression COMMA setNumbers
Rule 27    setNumbers -> expression
Rule 28    ifInst -> IF LPAREN expression RPAREN instruction
Rule 29    ifInst -> IF LPAREN expression RPAREN instruction ELSE instruction
Rule 30    forInst -> FOR IDENTIFIER direction IDENTIFIER DO instruction
Rule 31    forInst -> FOR IDENTIFIER direction set DO instruction
Rule 32    whileInst -> WHILE LPAREN expression RPAREN DO instruction
Rule 33    repeatInst -> REPEAT instruction whileInst
Rule 34    scanInst -> SCAN expression
Rule 35    direction -> MIN
Rule 36    direction -> MAX
Rule 37    printOutput -> PRINT outputType
Rule 38    printOutput -> PRINTLN outputType
Rule 39    outputType -> STRING
Rule 40    outputType -> expression
Rule 41    outputType -> expression COMMA outputType
Rule 42    expression -> binaryOp
Rule 43    binaryOp -> binaryOp PLUS binaryOp
Rule 44    binaryOp -> binaryOp MINUS binaryOp
Rule 45    binaryOp -> binaryOp TIMES binaryOp
Rule 46    binaryOp -> binaryOp DIVIDE binaryOp
Rule 47    binaryOp -> binaryOp MODULE binaryOp
Rule 48    binaryOp -> binaryOp AND binaryOp
Rule 49    binaryOp -> binaryOp OR binaryOp
Rule 50    binaryOp -> NOT binaryOp
Rule 51    binaryOp -> MINUS binaryOp
Rule 52    binaryOp -> LPAREN binaryOp RPAREN
Rule 53    binaryOp -> binaryOp LESSTHAN binaryOp
Rule 54    binaryOp -> binaryOp LESSEQUALTHAN binaryOp
Rule 55    binaryOp -> binaryOp GREATERTHAN binaryOp
Rule 56    binaryOp -> binaryOp GREATEREQUALTHAN binaryOp
Rule 57    binaryOp -> binaryOp EQUALS binaryOp
Rule 58    binaryOp -> binaryOp NOTEQUALS binaryOp
Rule 59    binaryOp -> binaryOp SETUNION binaryOp
Rule 60    binaryOp -> binaryOp SETDIFF binaryOp
Rule 61    binaryOp -> binaryOp SETINTERSECT binaryOp
Rule 62    binaryOp -> binaryOp SETMAPPLUS binaryOp
Rule 63    binaryOp -> binaryOp SETMAPMINUS binaryOp
Rule 64    binaryOp -> binaryOp SETMAPTIMES binaryOp
Rule 65    binaryOp -> binaryOp SETMAPDIVIDE binaryOp
Rule 66    binaryOp -> binaryOp SETMAPMODULE binaryOp
Rule 67    binaryOp -> binaryOp BELONGSTO binaryOp
Rule 68    binaryOp -> TRUE
Rule 69    binaryOp -> FALSE
Rule 70    binaryOp -> number
Rule 71    binaryOp -> set
Rule 72    binaryOp -> IDENTIFIER
Rule 73    number -> NUMBER

Terminals, with rules where they appear

AND                  : 48
ASSIGN               : 15 16
BELONGSTO            : 67
BOOL                 : 5
COMMA                : 8 26 41
COMMENT              : 
DIVIDE               : 46
DO                   : 30 31 32
ELSE                 : 29
EQUALS               : 57
FALSE                : 69
FOR                  : 30 31
GREATEREQUALTHAN     : 56
GREATERTHAN          : 55
IDENTIFIER           : 7 8 15 16 30 30 31 72
IF                   : 28 29
IN                   : 24
INT                  : 4
LCURLY               : 9 10 25
LESSEQUALTHAN        : 54
LESSTHAN             : 53
LPAREN               : 28 29 32 52
MAX                  : 36
MIN                  : 35
MINUS                : 44 51
MODULE               : 47
NOT                  : 50
NOTEQUALS            : 58
NUMBER               : 73
OR                   : 49
PLUS                 : 43
PRINT                : 37
PRINTLN              : 38
PROGRAM              : 1
RCURLY               : 9 10 25
RDOUBLEQUOTE         : 
REPEAT               : 33
RPAREN               : 28 29 32 52
SCAN                 : 34
SEMICOLON            : 2 3 12 13
SET                  : 6
SETDIFF              : 60
SETINTERSECT         : 61
SETMAPDIVIDE         : 65
SETMAPMINUS          : 63
SETMAPMODULE         : 66
SETMAPPLUS           : 62
SETMAPTIMES          : 64
SETMAXVALUE          : 
SETMINVALUE          : 
SETSIZE              : 
SETUNION             : 59
SIMPLEQUOTE          : 
STRING               : 39
TIMES                : 45
TRUE                 : 68
USING                : 24
WHILE                : 32
error                : 

Nonterminals, with rules where they appear

binaryOp             : 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 51 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67
block                : 23
declarationBlock     : 3 24
direction            : 30 31
empty                : 14
expression           : 15 26 27 28 29 32 34 40 41
forInst              : 21
id                   : 2 3 8
ifInst               : 17
instruction          : 1 12 13 28 29 29 30 31 32 33
instructionBlock     : 10 13 24
number               : 70
outputType           : 37 38 41
printOutput          : 18
program              : 0
repeatInst           : 20
scanInst             : 22
set                  : 16 31 71
setNumbers           : 25 26
types                : 2 3
usingInInst          : 9
whileInst            : 19 33

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM instruction

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . instruction
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 18
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 2

    (0) S' -> program .



state 3

    (21) instruction -> forInst .

    ELSE            reduce using rule 21 (instruction -> forInst .)
    $end            reduce using rule 21 (instruction -> forInst .)
    WHILE           reduce using rule 21 (instruction -> forInst .)
    SEMICOLON       reduce using rule 21 (instruction -> forInst .)


state 4

    (34) scanInst -> SCAN . expression
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    expression                     shift and go to state 31
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23

state 5

    (37) printOutput -> PRINT . outputType
    (39) outputType -> . STRING
    (40) outputType -> . expression
    (41) outputType -> . expression COMMA outputType
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    STRING          shift and go to state 33
    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    outputType                     shift and go to state 32
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23
    expression                     shift and go to state 34

state 6

    (32) whileInst -> WHILE . LPAREN expression RPAREN DO instruction

    LPAREN          shift and go to state 35


state 7

    (22) instruction -> scanInst .

    ELSE            reduce using rule 22 (instruction -> scanInst .)
    $end            reduce using rule 22 (instruction -> scanInst .)
    WHILE           reduce using rule 22 (instruction -> scanInst .)
    SEMICOLON       reduce using rule 22 (instruction -> scanInst .)


state 8

    (38) printOutput -> PRINTLN . outputType
    (39) outputType -> . STRING
    (40) outputType -> . expression
    (41) outputType -> . expression COMMA outputType
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    STRING          shift and go to state 33
    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    outputType                     shift and go to state 36
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23
    expression                     shift and go to state 34

state 9

    (19) instruction -> whileInst .

    ELSE            reduce using rule 19 (instruction -> whileInst .)
    $end            reduce using rule 19 (instruction -> whileInst .)
    WHILE           reduce using rule 19 (instruction -> whileInst .)
    SEMICOLON       reduce using rule 19 (instruction -> whileInst .)


state 10

    (15) instruction -> IDENTIFIER . ASSIGN expression
    (16) instruction -> IDENTIFIER . ASSIGN set

    ASSIGN          shift and go to state 37


state 11

    (17) instruction -> ifInst .

    ELSE            reduce using rule 17 (instruction -> ifInst .)
    $end            reduce using rule 17 (instruction -> ifInst .)
    WHILE           reduce using rule 17 (instruction -> ifInst .)
    SEMICOLON       reduce using rule 17 (instruction -> ifInst .)


state 12

    (33) repeatInst -> REPEAT . instruction whileInst
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 38
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 13

    (18) instruction -> printOutput .

    ELSE            reduce using rule 18 (instruction -> printOutput .)
    $end            reduce using rule 18 (instruction -> printOutput .)
    WHILE           reduce using rule 18 (instruction -> printOutput .)
    SEMICOLON       reduce using rule 18 (instruction -> printOutput .)


state 14

    (30) forInst -> FOR . IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> FOR . IDENTIFIER direction set DO instruction

    IDENTIFIER      shift and go to state 39


state 15

    (20) instruction -> repeatInst .

    ELSE            reduce using rule 20 (instruction -> repeatInst .)
    $end            reduce using rule 20 (instruction -> repeatInst .)
    WHILE           reduce using rule 20 (instruction -> repeatInst .)
    SEMICOLON       reduce using rule 20 (instruction -> repeatInst .)


state 16

    (28) ifInst -> IF . LPAREN expression RPAREN instruction
    (29) ifInst -> IF . LPAREN expression RPAREN instruction ELSE instruction

    LPAREN          shift and go to state 40


state 17

    (9) block -> LCURLY . usingInInst RCURLY
    (10) block -> LCURLY . instructionBlock RCURLY
    (24) usingInInst -> . USING declarationBlock IN instructionBlock
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instructionBlock -> . empty
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (11) empty -> .
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    USING           shift and go to state 45
    IDENTIFIER      shift and go to state 10
    RCURLY          reduce using rule 11 (empty -> .)
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    block                          shift and go to state 19
    instruction                    shift and go to state 43
    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instructionBlock               shift and go to state 41
    scanInst                       shift and go to state 7
    usingInInst                    shift and go to state 44
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 11
    empty                          shift and go to state 42

state 18

    (1) program -> PROGRAM instruction .

    $end            reduce using rule 1 (program -> PROGRAM instruction .)


state 19

    (23) instruction -> block .

    ELSE            reduce using rule 23 (instruction -> block .)
    $end            reduce using rule 23 (instruction -> block .)
    WHILE           reduce using rule 23 (instruction -> block .)
    SEMICOLON       reduce using rule 23 (instruction -> block .)


state 20

    (71) binaryOp -> set .

    PLUS            reduce using rule 71 (binaryOp -> set .)
    MINUS           reduce using rule 71 (binaryOp -> set .)
    TIMES           reduce using rule 71 (binaryOp -> set .)
    DIVIDE          reduce using rule 71 (binaryOp -> set .)
    MODULE          reduce using rule 71 (binaryOp -> set .)
    AND             reduce using rule 71 (binaryOp -> set .)
    OR              reduce using rule 71 (binaryOp -> set .)
    LESSTHAN        reduce using rule 71 (binaryOp -> set .)
    LESSEQUALTHAN   reduce using rule 71 (binaryOp -> set .)
    GREATERTHAN     reduce using rule 71 (binaryOp -> set .)
    GREATEREQUALTHAN reduce using rule 71 (binaryOp -> set .)
    EQUALS          reduce using rule 71 (binaryOp -> set .)
    NOTEQUALS       reduce using rule 71 (binaryOp -> set .)
    SETUNION        reduce using rule 71 (binaryOp -> set .)
    SETDIFF         reduce using rule 71 (binaryOp -> set .)
    SETINTERSECT    reduce using rule 71 (binaryOp -> set .)
    SETMAPPLUS      reduce using rule 71 (binaryOp -> set .)
    SETMAPMINUS     reduce using rule 71 (binaryOp -> set .)
    SETMAPTIMES     reduce using rule 71 (binaryOp -> set .)
    SETMAPDIVIDE    reduce using rule 71 (binaryOp -> set .)
    SETMAPMODULE    reduce using rule 71 (binaryOp -> set .)
    BELONGSTO       reduce using rule 71 (binaryOp -> set .)
    $end            reduce using rule 71 (binaryOp -> set .)
    WHILE           reduce using rule 71 (binaryOp -> set .)
    SEMICOLON       reduce using rule 71 (binaryOp -> set .)
    ELSE            reduce using rule 71 (binaryOp -> set .)
    COMMA           reduce using rule 71 (binaryOp -> set .)
    RCURLY          reduce using rule 71 (binaryOp -> set .)
    RPAREN          reduce using rule 71 (binaryOp -> set .)


state 21

    (70) binaryOp -> number .

    PLUS            reduce using rule 70 (binaryOp -> number .)
    MINUS           reduce using rule 70 (binaryOp -> number .)
    TIMES           reduce using rule 70 (binaryOp -> number .)
    DIVIDE          reduce using rule 70 (binaryOp -> number .)
    MODULE          reduce using rule 70 (binaryOp -> number .)
    AND             reduce using rule 70 (binaryOp -> number .)
    OR              reduce using rule 70 (binaryOp -> number .)
    LESSTHAN        reduce using rule 70 (binaryOp -> number .)
    LESSEQUALTHAN   reduce using rule 70 (binaryOp -> number .)
    GREATERTHAN     reduce using rule 70 (binaryOp -> number .)
    GREATEREQUALTHAN reduce using rule 70 (binaryOp -> number .)
    EQUALS          reduce using rule 70 (binaryOp -> number .)
    NOTEQUALS       reduce using rule 70 (binaryOp -> number .)
    SETUNION        reduce using rule 70 (binaryOp -> number .)
    SETDIFF         reduce using rule 70 (binaryOp -> number .)
    SETINTERSECT    reduce using rule 70 (binaryOp -> number .)
    SETMAPPLUS      reduce using rule 70 (binaryOp -> number .)
    SETMAPMINUS     reduce using rule 70 (binaryOp -> number .)
    SETMAPTIMES     reduce using rule 70 (binaryOp -> number .)
    SETMAPDIVIDE    reduce using rule 70 (binaryOp -> number .)
    SETMAPMODULE    reduce using rule 70 (binaryOp -> number .)
    BELONGSTO       reduce using rule 70 (binaryOp -> number .)
    $end            reduce using rule 70 (binaryOp -> number .)
    WHILE           reduce using rule 70 (binaryOp -> number .)
    SEMICOLON       reduce using rule 70 (binaryOp -> number .)
    ELSE            reduce using rule 70 (binaryOp -> number .)
    COMMA           reduce using rule 70 (binaryOp -> number .)
    RCURLY          reduce using rule 70 (binaryOp -> number .)
    RPAREN          reduce using rule 70 (binaryOp -> number .)


state 22

    (25) set -> LCURLY . setNumbers RCURLY
    (26) setNumbers -> . expression COMMA setNumbers
    (27) setNumbers -> . expression
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    setNumbers                     shift and go to state 46
    set                            shift and go to state 20
    expression                     shift and go to state 47
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23

state 23

    (42) expression -> binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    COMMA           reduce using rule 42 (expression -> binaryOp .)
    RCURLY          reduce using rule 42 (expression -> binaryOp .)
    RPAREN          reduce using rule 42 (expression -> binaryOp .)
    $end            reduce using rule 42 (expression -> binaryOp .)
    WHILE           reduce using rule 42 (expression -> binaryOp .)
    SEMICOLON       reduce using rule 42 (expression -> binaryOp .)
    ELSE            reduce using rule 42 (expression -> binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    AND             shift and go to state 63
    OR              shift and go to state 66
    LESSTHAN        shift and go to state 49
    LESSEQUALTHAN   shift and go to state 64
    GREATERTHAN     shift and go to state 62
    GREATEREQUALTHAN shift and go to state 57
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69


state 24

    (68) binaryOp -> TRUE .

    PLUS            reduce using rule 68 (binaryOp -> TRUE .)
    MINUS           reduce using rule 68 (binaryOp -> TRUE .)
    TIMES           reduce using rule 68 (binaryOp -> TRUE .)
    DIVIDE          reduce using rule 68 (binaryOp -> TRUE .)
    MODULE          reduce using rule 68 (binaryOp -> TRUE .)
    AND             reduce using rule 68 (binaryOp -> TRUE .)
    OR              reduce using rule 68 (binaryOp -> TRUE .)
    LESSTHAN        reduce using rule 68 (binaryOp -> TRUE .)
    LESSEQUALTHAN   reduce using rule 68 (binaryOp -> TRUE .)
    GREATERTHAN     reduce using rule 68 (binaryOp -> TRUE .)
    GREATEREQUALTHAN reduce using rule 68 (binaryOp -> TRUE .)
    EQUALS          reduce using rule 68 (binaryOp -> TRUE .)
    NOTEQUALS       reduce using rule 68 (binaryOp -> TRUE .)
    SETUNION        reduce using rule 68 (binaryOp -> TRUE .)
    SETDIFF         reduce using rule 68 (binaryOp -> TRUE .)
    SETINTERSECT    reduce using rule 68 (binaryOp -> TRUE .)
    SETMAPPLUS      reduce using rule 68 (binaryOp -> TRUE .)
    SETMAPMINUS     reduce using rule 68 (binaryOp -> TRUE .)
    SETMAPTIMES     reduce using rule 68 (binaryOp -> TRUE .)
    SETMAPDIVIDE    reduce using rule 68 (binaryOp -> TRUE .)
    SETMAPMODULE    reduce using rule 68 (binaryOp -> TRUE .)
    BELONGSTO       reduce using rule 68 (binaryOp -> TRUE .)
    $end            reduce using rule 68 (binaryOp -> TRUE .)
    WHILE           reduce using rule 68 (binaryOp -> TRUE .)
    SEMICOLON       reduce using rule 68 (binaryOp -> TRUE .)
    ELSE            reduce using rule 68 (binaryOp -> TRUE .)
    COMMA           reduce using rule 68 (binaryOp -> TRUE .)
    RCURLY          reduce using rule 68 (binaryOp -> TRUE .)
    RPAREN          reduce using rule 68 (binaryOp -> TRUE .)


state 25

    (51) binaryOp -> MINUS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 70

state 26

    (73) number -> NUMBER .

    PLUS            reduce using rule 73 (number -> NUMBER .)
    MINUS           reduce using rule 73 (number -> NUMBER .)
    TIMES           reduce using rule 73 (number -> NUMBER .)
    DIVIDE          reduce using rule 73 (number -> NUMBER .)
    MODULE          reduce using rule 73 (number -> NUMBER .)
    AND             reduce using rule 73 (number -> NUMBER .)
    OR              reduce using rule 73 (number -> NUMBER .)
    LESSTHAN        reduce using rule 73 (number -> NUMBER .)
    LESSEQUALTHAN   reduce using rule 73 (number -> NUMBER .)
    GREATERTHAN     reduce using rule 73 (number -> NUMBER .)
    GREATEREQUALTHAN reduce using rule 73 (number -> NUMBER .)
    EQUALS          reduce using rule 73 (number -> NUMBER .)
    NOTEQUALS       reduce using rule 73 (number -> NUMBER .)
    SETUNION        reduce using rule 73 (number -> NUMBER .)
    SETDIFF         reduce using rule 73 (number -> NUMBER .)
    SETINTERSECT    reduce using rule 73 (number -> NUMBER .)
    SETMAPPLUS      reduce using rule 73 (number -> NUMBER .)
    SETMAPMINUS     reduce using rule 73 (number -> NUMBER .)
    SETMAPTIMES     reduce using rule 73 (number -> NUMBER .)
    SETMAPDIVIDE    reduce using rule 73 (number -> NUMBER .)
    SETMAPMODULE    reduce using rule 73 (number -> NUMBER .)
    BELONGSTO       reduce using rule 73 (number -> NUMBER .)
    COMMA           reduce using rule 73 (number -> NUMBER .)
    $end            reduce using rule 73 (number -> NUMBER .)
    WHILE           reduce using rule 73 (number -> NUMBER .)
    SEMICOLON       reduce using rule 73 (number -> NUMBER .)
    ELSE            reduce using rule 73 (number -> NUMBER .)
    RCURLY          reduce using rule 73 (number -> NUMBER .)
    RPAREN          reduce using rule 73 (number -> NUMBER .)


state 27

    (52) binaryOp -> LPAREN . binaryOp RPAREN
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 71

state 28

    (69) binaryOp -> FALSE .

    PLUS            reduce using rule 69 (binaryOp -> FALSE .)
    MINUS           reduce using rule 69 (binaryOp -> FALSE .)
    TIMES           reduce using rule 69 (binaryOp -> FALSE .)
    DIVIDE          reduce using rule 69 (binaryOp -> FALSE .)
    MODULE          reduce using rule 69 (binaryOp -> FALSE .)
    AND             reduce using rule 69 (binaryOp -> FALSE .)
    OR              reduce using rule 69 (binaryOp -> FALSE .)
    LESSTHAN        reduce using rule 69 (binaryOp -> FALSE .)
    LESSEQUALTHAN   reduce using rule 69 (binaryOp -> FALSE .)
    GREATERTHAN     reduce using rule 69 (binaryOp -> FALSE .)
    GREATEREQUALTHAN reduce using rule 69 (binaryOp -> FALSE .)
    EQUALS          reduce using rule 69 (binaryOp -> FALSE .)
    NOTEQUALS       reduce using rule 69 (binaryOp -> FALSE .)
    SETUNION        reduce using rule 69 (binaryOp -> FALSE .)
    SETDIFF         reduce using rule 69 (binaryOp -> FALSE .)
    SETINTERSECT    reduce using rule 69 (binaryOp -> FALSE .)
    SETMAPPLUS      reduce using rule 69 (binaryOp -> FALSE .)
    SETMAPMINUS     reduce using rule 69 (binaryOp -> FALSE .)
    SETMAPTIMES     reduce using rule 69 (binaryOp -> FALSE .)
    SETMAPDIVIDE    reduce using rule 69 (binaryOp -> FALSE .)
    SETMAPMODULE    reduce using rule 69 (binaryOp -> FALSE .)
    BELONGSTO       reduce using rule 69 (binaryOp -> FALSE .)
    $end            reduce using rule 69 (binaryOp -> FALSE .)
    WHILE           reduce using rule 69 (binaryOp -> FALSE .)
    SEMICOLON       reduce using rule 69 (binaryOp -> FALSE .)
    ELSE            reduce using rule 69 (binaryOp -> FALSE .)
    COMMA           reduce using rule 69 (binaryOp -> FALSE .)
    RCURLY          reduce using rule 69 (binaryOp -> FALSE .)
    RPAREN          reduce using rule 69 (binaryOp -> FALSE .)


state 29

    (72) binaryOp -> IDENTIFIER .

    PLUS            reduce using rule 72 (binaryOp -> IDENTIFIER .)
    MINUS           reduce using rule 72 (binaryOp -> IDENTIFIER .)
    TIMES           reduce using rule 72 (binaryOp -> IDENTIFIER .)
    DIVIDE          reduce using rule 72 (binaryOp -> IDENTIFIER .)
    MODULE          reduce using rule 72 (binaryOp -> IDENTIFIER .)
    AND             reduce using rule 72 (binaryOp -> IDENTIFIER .)
    OR              reduce using rule 72 (binaryOp -> IDENTIFIER .)
    LESSTHAN        reduce using rule 72 (binaryOp -> IDENTIFIER .)
    LESSEQUALTHAN   reduce using rule 72 (binaryOp -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 72 (binaryOp -> IDENTIFIER .)
    GREATEREQUALTHAN reduce using rule 72 (binaryOp -> IDENTIFIER .)
    EQUALS          reduce using rule 72 (binaryOp -> IDENTIFIER .)
    NOTEQUALS       reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETUNION        reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETDIFF         reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETINTERSECT    reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETMAPPLUS      reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETMAPMINUS     reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETMAPTIMES     reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETMAPDIVIDE    reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SETMAPMODULE    reduce using rule 72 (binaryOp -> IDENTIFIER .)
    BELONGSTO       reduce using rule 72 (binaryOp -> IDENTIFIER .)
    $end            reduce using rule 72 (binaryOp -> IDENTIFIER .)
    WHILE           reduce using rule 72 (binaryOp -> IDENTIFIER .)
    SEMICOLON       reduce using rule 72 (binaryOp -> IDENTIFIER .)
    ELSE            reduce using rule 72 (binaryOp -> IDENTIFIER .)
    COMMA           reduce using rule 72 (binaryOp -> IDENTIFIER .)
    RCURLY          reduce using rule 72 (binaryOp -> IDENTIFIER .)
    RPAREN          reduce using rule 72 (binaryOp -> IDENTIFIER .)


state 30

    (50) binaryOp -> NOT . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 72

state 31

    (34) scanInst -> SCAN expression .

    $end            reduce using rule 34 (scanInst -> SCAN expression .)
    ELSE            reduce using rule 34 (scanInst -> SCAN expression .)
    WHILE           reduce using rule 34 (scanInst -> SCAN expression .)
    SEMICOLON       reduce using rule 34 (scanInst -> SCAN expression .)


state 32

    (37) printOutput -> PRINT outputType .

    ELSE            reduce using rule 37 (printOutput -> PRINT outputType .)
    $end            reduce using rule 37 (printOutput -> PRINT outputType .)
    WHILE           reduce using rule 37 (printOutput -> PRINT outputType .)
    SEMICOLON       reduce using rule 37 (printOutput -> PRINT outputType .)


state 33

    (39) outputType -> STRING .

    $end            reduce using rule 39 (outputType -> STRING .)
    WHILE           reduce using rule 39 (outputType -> STRING .)
    SEMICOLON       reduce using rule 39 (outputType -> STRING .)
    ELSE            reduce using rule 39 (outputType -> STRING .)


state 34

    (40) outputType -> expression .
    (41) outputType -> expression . COMMA outputType

    $end            reduce using rule 40 (outputType -> expression .)
    WHILE           reduce using rule 40 (outputType -> expression .)
    SEMICOLON       reduce using rule 40 (outputType -> expression .)
    ELSE            reduce using rule 40 (outputType -> expression .)
    COMMA           shift and go to state 73


state 35

    (32) whileInst -> WHILE LPAREN . expression RPAREN DO instruction
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23
    expression                     shift and go to state 74

state 36

    (38) printOutput -> PRINTLN outputType .

    ELSE            reduce using rule 38 (printOutput -> PRINTLN outputType .)
    $end            reduce using rule 38 (printOutput -> PRINTLN outputType .)
    WHILE           reduce using rule 38 (printOutput -> PRINTLN outputType .)
    SEMICOLON       reduce using rule 38 (printOutput -> PRINTLN outputType .)


state 37

    (15) instruction -> IDENTIFIER ASSIGN . expression
    (16) instruction -> IDENTIFIER ASSIGN . set
    (42) expression -> . binaryOp
    (25) set -> . LCURLY setNumbers RCURLY
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER

    LCURLY          shift and go to state 22
    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26

    set                            shift and go to state 75
    expression                     shift and go to state 76
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23

state 38

    (33) repeatInst -> REPEAT instruction . whileInst
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction

    WHILE           shift and go to state 6

    whileInst                      shift and go to state 77

state 39

    (30) forInst -> FOR IDENTIFIER . direction IDENTIFIER DO instruction
    (31) forInst -> FOR IDENTIFIER . direction set DO instruction
    (35) direction -> . MIN
    (36) direction -> . MAX

    MIN             shift and go to state 79
    MAX             shift and go to state 80

    direction                      shift and go to state 78

state 40

    (28) ifInst -> IF LPAREN . expression RPAREN instruction
    (29) ifInst -> IF LPAREN . expression RPAREN instruction ELSE instruction
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23
    expression                     shift and go to state 81

state 41

    (10) block -> LCURLY instructionBlock . RCURLY

    RCURLY          shift and go to state 82


state 42

    (14) instructionBlock -> empty .

    RCURLY          reduce using rule 14 (instructionBlock -> empty .)


state 43

    (12) instructionBlock -> instruction . SEMICOLON
    (13) instructionBlock -> instruction . SEMICOLON instructionBlock

    SEMICOLON       shift and go to state 83


state 44

    (9) block -> LCURLY usingInInst . RCURLY

    RCURLY          shift and go to state 84


state 45

    (24) usingInInst -> USING . declarationBlock IN instructionBlock
    (2) declarationBlock -> . types id SEMICOLON
    (3) declarationBlock -> . types id SEMICOLON declarationBlock
    (4) types -> . INT
    (5) types -> . BOOL
    (6) types -> . SET

    INT             shift and go to state 86
    BOOL            shift and go to state 87
    SET             shift and go to state 85

    types                          shift and go to state 88
    declarationBlock               shift and go to state 89

state 46

    (25) set -> LCURLY setNumbers . RCURLY

    RCURLY          shift and go to state 90


state 47

    (26) setNumbers -> expression . COMMA setNumbers
    (27) setNumbers -> expression .

    COMMA           shift and go to state 91
    RCURLY          reduce using rule 27 (setNumbers -> expression .)


state 48

    (58) binaryOp -> binaryOp NOTEQUALS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 92

state 49

    (53) binaryOp -> binaryOp LESSTHAN . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 93

state 50

    (66) binaryOp -> binaryOp SETMAPMODULE . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 94

state 51

    (44) binaryOp -> binaryOp MINUS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 95

state 52

    (59) binaryOp -> binaryOp SETUNION . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 96

state 53

    (64) binaryOp -> binaryOp SETMAPTIMES . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 97

state 54

    (61) binaryOp -> binaryOp SETINTERSECT . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 98

state 55

    (43) binaryOp -> binaryOp PLUS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 99

state 56

    (60) binaryOp -> binaryOp SETDIFF . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 100

state 57

    (56) binaryOp -> binaryOp GREATEREQUALTHAN . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 101

state 58

    (46) binaryOp -> binaryOp DIVIDE . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 102

state 59

    (57) binaryOp -> binaryOp EQUALS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 103

state 60

    (47) binaryOp -> binaryOp MODULE . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 104

state 61

    (45) binaryOp -> binaryOp TIMES . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 105

state 62

    (55) binaryOp -> binaryOp GREATERTHAN . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 106

state 63

    (48) binaryOp -> binaryOp AND . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 107

state 64

    (54) binaryOp -> binaryOp LESSEQUALTHAN . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 108

state 65

    (62) binaryOp -> binaryOp SETMAPPLUS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 109

state 66

    (49) binaryOp -> binaryOp OR . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 110

state 67

    (65) binaryOp -> binaryOp SETMAPDIVIDE . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 111

state 68

    (63) binaryOp -> binaryOp SETMAPMINUS . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 112

state 69

    (67) binaryOp -> binaryOp BELONGSTO . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    number                         shift and go to state 21
    binaryOp                       shift and go to state 113

state 70

    (51) binaryOp -> MINUS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    MINUS           reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    AND             reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    OR              reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    LESSTHAN        reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    GREATERTHAN     reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    EQUALS          reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    NOTEQUALS       reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    $end            reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    WHILE           reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    SEMICOLON       reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    ELSE            reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    COMMA           reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    RCURLY          reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    RPAREN          reduce using rule 51 (binaryOp -> MINUS binaryOp .)
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! TIMES           [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! MODULE          [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETUNION        [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 51 (binaryOp -> MINUS binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 71

    (52) binaryOp -> LPAREN binaryOp . RPAREN
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    RPAREN          shift and go to state 114
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    AND             shift and go to state 63
    OR              shift and go to state 66
    LESSTHAN        shift and go to state 49
    LESSEQUALTHAN   shift and go to state 64
    GREATERTHAN     shift and go to state 62
    GREATEREQUALTHAN shift and go to state 57
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69


state 72

    (50) binaryOp -> NOT binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 50 (binaryOp -> NOT binaryOp .)
    OR              reduce using rule 50 (binaryOp -> NOT binaryOp .)
    $end            reduce using rule 50 (binaryOp -> NOT binaryOp .)
    WHILE           reduce using rule 50 (binaryOp -> NOT binaryOp .)
    SEMICOLON       reduce using rule 50 (binaryOp -> NOT binaryOp .)
    ELSE            reduce using rule 50 (binaryOp -> NOT binaryOp .)
    COMMA           reduce using rule 50 (binaryOp -> NOT binaryOp .)
    RCURLY          reduce using rule 50 (binaryOp -> NOT binaryOp .)
    RPAREN          reduce using rule 50 (binaryOp -> NOT binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    LESSTHAN        shift and go to state 49
    LESSEQUALTHAN   shift and go to state 64
    GREATERTHAN     shift and go to state 62
    GREATEREQUALTHAN shift and go to state 57
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! MINUS           [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! TIMES           [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! DIVIDE          [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! MODULE          [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! LESSTHAN        [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! LESSEQUALTHAN   [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! GREATERTHAN     [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! GREATEREQUALTHAN [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! EQUALS          [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETUNION        [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETDIFF         [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 50 (binaryOp -> NOT binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]


state 73

    (41) outputType -> expression COMMA . outputType
    (39) outputType -> . STRING
    (40) outputType -> . expression
    (41) outputType -> . expression COMMA outputType
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    STRING          shift and go to state 33
    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    set                            shift and go to state 20
    outputType                     shift and go to state 115
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23
    expression                     shift and go to state 34

state 74

    (32) whileInst -> WHILE LPAREN expression . RPAREN DO instruction

    RPAREN          shift and go to state 116


state 75

    (16) instruction -> IDENTIFIER ASSIGN set .
    (71) binaryOp -> set .

  ! reduce/reduce conflict for $end resolved using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
  ! reduce/reduce conflict for WHILE resolved using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
  ! reduce/reduce conflict for ELSE resolved using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
    ELSE            reduce using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
    $end            reduce using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
    WHILE           reduce using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
    SEMICOLON       reduce using rule 16 (instruction -> IDENTIFIER ASSIGN set .)
    PLUS            reduce using rule 71 (binaryOp -> set .)
    MINUS           reduce using rule 71 (binaryOp -> set .)
    TIMES           reduce using rule 71 (binaryOp -> set .)
    DIVIDE          reduce using rule 71 (binaryOp -> set .)
    MODULE          reduce using rule 71 (binaryOp -> set .)
    AND             reduce using rule 71 (binaryOp -> set .)
    OR              reduce using rule 71 (binaryOp -> set .)
    LESSTHAN        reduce using rule 71 (binaryOp -> set .)
    LESSEQUALTHAN   reduce using rule 71 (binaryOp -> set .)
    GREATERTHAN     reduce using rule 71 (binaryOp -> set .)
    GREATEREQUALTHAN reduce using rule 71 (binaryOp -> set .)
    EQUALS          reduce using rule 71 (binaryOp -> set .)
    NOTEQUALS       reduce using rule 71 (binaryOp -> set .)
    SETUNION        reduce using rule 71 (binaryOp -> set .)
    SETDIFF         reduce using rule 71 (binaryOp -> set .)
    SETINTERSECT    reduce using rule 71 (binaryOp -> set .)
    SETMAPPLUS      reduce using rule 71 (binaryOp -> set .)
    SETMAPMINUS     reduce using rule 71 (binaryOp -> set .)
    SETMAPTIMES     reduce using rule 71 (binaryOp -> set .)
    SETMAPDIVIDE    reduce using rule 71 (binaryOp -> set .)
    SETMAPMODULE    reduce using rule 71 (binaryOp -> set .)
    BELONGSTO       reduce using rule 71 (binaryOp -> set .)

  ! $end            [ reduce using rule 71 (binaryOp -> set .) ]
  ! WHILE           [ reduce using rule 71 (binaryOp -> set .) ]
  ! SEMICOLON       [ reduce using rule 71 (binaryOp -> set .) ]
  ! ELSE            [ reduce using rule 71 (binaryOp -> set .) ]


state 76

    (15) instruction -> IDENTIFIER ASSIGN expression .

    ELSE            reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 15 (instruction -> IDENTIFIER ASSIGN expression .)


state 77

    (33) repeatInst -> REPEAT instruction whileInst .

    ELSE            reduce using rule 33 (repeatInst -> REPEAT instruction whileInst .)
    $end            reduce using rule 33 (repeatInst -> REPEAT instruction whileInst .)
    WHILE           reduce using rule 33 (repeatInst -> REPEAT instruction whileInst .)
    SEMICOLON       reduce using rule 33 (repeatInst -> REPEAT instruction whileInst .)


state 78

    (30) forInst -> FOR IDENTIFIER direction . IDENTIFIER DO instruction
    (31) forInst -> FOR IDENTIFIER direction . set DO instruction
    (25) set -> . LCURLY setNumbers RCURLY

    IDENTIFIER      shift and go to state 118
    LCURLY          shift and go to state 22

    set                            shift and go to state 117

state 79

    (35) direction -> MIN .

    IDENTIFIER      reduce using rule 35 (direction -> MIN .)
    LCURLY          reduce using rule 35 (direction -> MIN .)


state 80

    (36) direction -> MAX .

    IDENTIFIER      reduce using rule 36 (direction -> MAX .)
    LCURLY          reduce using rule 36 (direction -> MAX .)


state 81

    (28) ifInst -> IF LPAREN expression . RPAREN instruction
    (29) ifInst -> IF LPAREN expression . RPAREN instruction ELSE instruction

    RPAREN          shift and go to state 119


state 82

    (10) block -> LCURLY instructionBlock RCURLY .

    $end            reduce using rule 10 (block -> LCURLY instructionBlock RCURLY .)
    WHILE           reduce using rule 10 (block -> LCURLY instructionBlock RCURLY .)
    ELSE            reduce using rule 10 (block -> LCURLY instructionBlock RCURLY .)
    SEMICOLON       reduce using rule 10 (block -> LCURLY instructionBlock RCURLY .)


state 83

    (12) instructionBlock -> instruction SEMICOLON .
    (13) instructionBlock -> instruction SEMICOLON . instructionBlock
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instructionBlock -> . empty
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (11) empty -> .
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

  ! reduce/reduce conflict for RCURLY resolved using rule 11 (empty -> .)
    IDENTIFIER      shift and go to state 10
    RCURLY          reduce using rule 11 (empty -> .)
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

  ! RCURLY          [ reduce using rule 12 (instructionBlock -> instruction SEMICOLON .) ]

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 43
    scanInst                       shift and go to state 7
    block                          shift and go to state 19
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    instructionBlock               shift and go to state 120
    empty                          shift and go to state 42
    ifInst                         shift and go to state 11

state 84

    (9) block -> LCURLY usingInInst RCURLY .

    $end            reduce using rule 9 (block -> LCURLY usingInInst RCURLY .)
    WHILE           reduce using rule 9 (block -> LCURLY usingInInst RCURLY .)
    ELSE            reduce using rule 9 (block -> LCURLY usingInInst RCURLY .)
    SEMICOLON       reduce using rule 9 (block -> LCURLY usingInInst RCURLY .)


state 85

    (6) types -> SET .

    IDENTIFIER      reduce using rule 6 (types -> SET .)


state 86

    (4) types -> INT .

    IDENTIFIER      reduce using rule 4 (types -> INT .)


state 87

    (5) types -> BOOL .

    IDENTIFIER      reduce using rule 5 (types -> BOOL .)


state 88

    (2) declarationBlock -> types . id SEMICOLON
    (3) declarationBlock -> types . id SEMICOLON declarationBlock
    (7) id -> . IDENTIFIER
    (8) id -> . IDENTIFIER COMMA id

    IDENTIFIER      shift and go to state 121

    id                             shift and go to state 122

state 89

    (24) usingInInst -> USING declarationBlock . IN instructionBlock

    IN              shift and go to state 123


state 90

    (25) set -> LCURLY setNumbers RCURLY .

    PLUS            reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    MINUS           reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    TIMES           reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    DIVIDE          reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    MODULE          reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    AND             reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    OR              reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    LESSTHAN        reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    LESSEQUALTHAN   reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    GREATERTHAN     reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    GREATEREQUALTHAN reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    EQUALS          reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    NOTEQUALS       reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETUNION        reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETDIFF         reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETINTERSECT    reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETMAPPLUS      reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETMAPMINUS     reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETMAPTIMES     reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETMAPDIVIDE    reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SETMAPMODULE    reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    BELONGSTO       reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    $end            reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    WHILE           reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    SEMICOLON       reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    ELSE            reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    COMMA           reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    RCURLY          reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    RPAREN          reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)
    DO              reduce using rule 25 (set -> LCURLY setNumbers RCURLY .)


state 91

    (26) setNumbers -> expression COMMA . setNumbers
    (26) setNumbers -> . expression COMMA setNumbers
    (27) setNumbers -> . expression
    (42) expression -> . binaryOp
    (43) binaryOp -> . binaryOp PLUS binaryOp
    (44) binaryOp -> . binaryOp MINUS binaryOp
    (45) binaryOp -> . binaryOp TIMES binaryOp
    (46) binaryOp -> . binaryOp DIVIDE binaryOp
    (47) binaryOp -> . binaryOp MODULE binaryOp
    (48) binaryOp -> . binaryOp AND binaryOp
    (49) binaryOp -> . binaryOp OR binaryOp
    (50) binaryOp -> . NOT binaryOp
    (51) binaryOp -> . MINUS binaryOp
    (52) binaryOp -> . LPAREN binaryOp RPAREN
    (53) binaryOp -> . binaryOp LESSTHAN binaryOp
    (54) binaryOp -> . binaryOp LESSEQUALTHAN binaryOp
    (55) binaryOp -> . binaryOp GREATERTHAN binaryOp
    (56) binaryOp -> . binaryOp GREATEREQUALTHAN binaryOp
    (57) binaryOp -> . binaryOp EQUALS binaryOp
    (58) binaryOp -> . binaryOp NOTEQUALS binaryOp
    (59) binaryOp -> . binaryOp SETUNION binaryOp
    (60) binaryOp -> . binaryOp SETDIFF binaryOp
    (61) binaryOp -> . binaryOp SETINTERSECT binaryOp
    (62) binaryOp -> . binaryOp SETMAPPLUS binaryOp
    (63) binaryOp -> . binaryOp SETMAPMINUS binaryOp
    (64) binaryOp -> . binaryOp SETMAPTIMES binaryOp
    (65) binaryOp -> . binaryOp SETMAPDIVIDE binaryOp
    (66) binaryOp -> . binaryOp SETMAPMODULE binaryOp
    (67) binaryOp -> . binaryOp BELONGSTO binaryOp
    (68) binaryOp -> . TRUE
    (69) binaryOp -> . FALSE
    (70) binaryOp -> . number
    (71) binaryOp -> . set
    (72) binaryOp -> . IDENTIFIER
    (73) number -> . NUMBER
    (25) set -> . LCURLY setNumbers RCURLY

    NOT             shift and go to state 30
    MINUS           shift and go to state 25
    LPAREN          shift and go to state 27
    TRUE            shift and go to state 24
    FALSE           shift and go to state 28
    IDENTIFIER      shift and go to state 29
    NUMBER          shift and go to state 26
    LCURLY          shift and go to state 22

    setNumbers                     shift and go to state 124
    set                            shift and go to state 20
    expression                     shift and go to state 47
    number                         shift and go to state 21
    binaryOp                       shift and go to state 23

state 92

    (58) binaryOp -> binaryOp NOTEQUALS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    OR              reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    LESSTHAN        reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    LESSEQUALTHAN   reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    GREATERTHAN     reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    GREATEREQUALTHAN reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    EQUALS          reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    NOTEQUALS       reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    $end            reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    WHILE           reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    SEMICOLON       reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    ELSE            reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    COMMA           reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    RCURLY          reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    RPAREN          reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! MINUS           [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! TIMES           [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! MODULE          [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETUNION        [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 58 (binaryOp -> binaryOp NOTEQUALS binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 93

    (53) binaryOp -> binaryOp LESSTHAN binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    OR              reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    LESSTHAN        reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    GREATERTHAN     reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    $end            reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    WHILE           reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    SEMICOLON       reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    ELSE            reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    COMMA           reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    RCURLY          reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    RPAREN          reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 53 (binaryOp -> binaryOp LESSTHAN binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]


state 94

    (66) binaryOp -> binaryOp SETMAPMODULE binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    MINUS           reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    TIMES           reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    DIVIDE          reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    MODULE          reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    AND             reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    OR              reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    LESSTHAN        reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    LESSEQUALTHAN   reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    GREATERTHAN     reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    GREATEREQUALTHAN reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    EQUALS          reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    NOTEQUALS       reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETUNION        reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETDIFF         reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETINTERSECT    reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPPLUS      reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPMINUS     reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPTIMES     reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPDIVIDE    reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SETMAPMODULE    reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    $end            reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    WHILE           reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    SEMICOLON       reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    ELSE            reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    COMMA           reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    RCURLY          reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    RPAREN          reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .)
    BELONGSTO       shift and go to state 69

  ! BELONGSTO       [ reduce using rule 66 (binaryOp -> binaryOp SETMAPMODULE binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]
  ! SETMAPPLUS      [ shift and go to state 65 ]
  ! SETMAPMINUS     [ shift and go to state 68 ]
  ! SETMAPTIMES     [ shift and go to state 53 ]
  ! SETMAPDIVIDE    [ shift and go to state 67 ]
  ! SETMAPMODULE    [ shift and go to state 50 ]


state 95

    (44) binaryOp -> binaryOp MINUS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    MINUS           reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    AND             reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    OR              reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    LESSTHAN        reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    GREATERTHAN     reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    EQUALS          reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    NOTEQUALS       reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    $end            reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    WHILE           reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    SEMICOLON       reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    ELSE            reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    COMMA           reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    RCURLY          reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    RPAREN          reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .)
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! TIMES           [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! MODULE          [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETUNION        [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 44 (binaryOp -> binaryOp MINUS binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 96

    (59) binaryOp -> binaryOp SETUNION binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    MINUS           reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    TIMES           reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    DIVIDE          reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    MODULE          reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    AND             reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    OR              reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    LESSTHAN        reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    LESSEQUALTHAN   reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    GREATERTHAN     reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    GREATEREQUALTHAN reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    EQUALS          reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    NOTEQUALS       reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    SETUNION        reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    SETDIFF         reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    $end            reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    WHILE           reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    SEMICOLON       reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    ELSE            reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    COMMA           reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    RCURLY          reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    RPAREN          reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .)
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETINTERSECT    [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 59 (binaryOp -> binaryOp SETUNION binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]


state 97

    (64) binaryOp -> binaryOp SETMAPTIMES binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    MINUS           reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    TIMES           reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    DIVIDE          reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    MODULE          reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    AND             reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    OR              reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    LESSTHAN        reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    LESSEQUALTHAN   reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    GREATERTHAN     reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    GREATEREQUALTHAN reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    EQUALS          reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    NOTEQUALS       reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETUNION        reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETDIFF         reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETINTERSECT    reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPPLUS      reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPMINUS     reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPTIMES     reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPDIVIDE    reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SETMAPMODULE    reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    $end            reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    WHILE           reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    SEMICOLON       reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    ELSE            reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    COMMA           reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    RCURLY          reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    RPAREN          reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .)
    BELONGSTO       shift and go to state 69

  ! BELONGSTO       [ reduce using rule 64 (binaryOp -> binaryOp SETMAPTIMES binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]
  ! SETMAPPLUS      [ shift and go to state 65 ]
  ! SETMAPMINUS     [ shift and go to state 68 ]
  ! SETMAPTIMES     [ shift and go to state 53 ]
  ! SETMAPDIVIDE    [ shift and go to state 67 ]
  ! SETMAPMODULE    [ shift and go to state 50 ]


state 98

    (61) binaryOp -> binaryOp SETINTERSECT binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    MINUS           reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    TIMES           reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    DIVIDE          reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    MODULE          reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    AND             reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    OR              reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    LESSTHAN        reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    LESSEQUALTHAN   reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    GREATERTHAN     reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    GREATEREQUALTHAN reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    EQUALS          reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    NOTEQUALS       reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETUNION        reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETDIFF         reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETINTERSECT    reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    $end            reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    WHILE           reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SEMICOLON       reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    ELSE            reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    COMMA           reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    RCURLY          reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    RPAREN          reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .)
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETMAPPLUS      [ reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 61 (binaryOp -> binaryOp SETINTERSECT binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]


state 99

    (43) binaryOp -> binaryOp PLUS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    MINUS           reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    AND             reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    OR              reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    LESSTHAN        reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    GREATERTHAN     reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    EQUALS          reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    NOTEQUALS       reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    $end            reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    WHILE           reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    SEMICOLON       reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    ELSE            reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    COMMA           reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    RCURLY          reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    RPAREN          reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .)
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! TIMES           [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! MODULE          [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETUNION        [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 43 (binaryOp -> binaryOp PLUS binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 100

    (60) binaryOp -> binaryOp SETDIFF binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    MINUS           reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    TIMES           reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    DIVIDE          reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    MODULE          reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    AND             reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    OR              reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    LESSTHAN        reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    LESSEQUALTHAN   reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    GREATERTHAN     reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    GREATEREQUALTHAN reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    EQUALS          reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    NOTEQUALS       reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SETUNION        reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SETDIFF         reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    $end            reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    WHILE           reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SEMICOLON       reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    ELSE            reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    COMMA           reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    RCURLY          reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    RPAREN          reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .)
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETINTERSECT    [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 60 (binaryOp -> binaryOp SETDIFF binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]


state 101

    (56) binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    OR              reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    LESSTHAN        reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    GREATERTHAN     reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    $end            reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    WHILE           reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    SEMICOLON       reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    ELSE            reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    COMMA           reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    RCURLY          reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    RPAREN          reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 56 (binaryOp -> binaryOp GREATEREQUALTHAN binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]


state 102

    (46) binaryOp -> binaryOp DIVIDE binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    MINUS           reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    TIMES           reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    DIVIDE          reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    MODULE          reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    AND             reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    OR              reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    LESSTHAN        reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    LESSEQUALTHAN   reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    GREATERTHAN     reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    GREATEREQUALTHAN reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    EQUALS          reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    NOTEQUALS       reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    $end            reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    WHILE           reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    SEMICOLON       reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    ELSE            reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    COMMA           reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    RCURLY          reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    RPAREN          reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .)
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETUNION        [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETDIFF         [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 46 (binaryOp -> binaryOp DIVIDE binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 103

    (57) binaryOp -> binaryOp EQUALS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    OR              reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    LESSTHAN        reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    LESSEQUALTHAN   reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    GREATERTHAN     reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    GREATEREQUALTHAN reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    EQUALS          reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    NOTEQUALS       reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    $end            reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    WHILE           reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    SEMICOLON       reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    ELSE            reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    COMMA           reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    RCURLY          reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    RPAREN          reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! MINUS           [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! TIMES           [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! DIVIDE          [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! MODULE          [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETUNION        [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETDIFF         [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 57 (binaryOp -> binaryOp EQUALS binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 104

    (47) binaryOp -> binaryOp MODULE binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    MINUS           reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    TIMES           reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    DIVIDE          reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    MODULE          reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    AND             reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    OR              reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    LESSTHAN        reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    LESSEQUALTHAN   reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    GREATERTHAN     reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    GREATEREQUALTHAN reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    EQUALS          reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    NOTEQUALS       reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    $end            reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    WHILE           reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    SEMICOLON       reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    ELSE            reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    COMMA           reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    RCURLY          reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    RPAREN          reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .)
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETUNION        [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETDIFF         [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 47 (binaryOp -> binaryOp MODULE binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 105

    (45) binaryOp -> binaryOp TIMES binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    MINUS           reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    TIMES           reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    DIVIDE          reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    MODULE          reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    AND             reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    OR              reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    LESSTHAN        reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    LESSEQUALTHAN   reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    GREATERTHAN     reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    GREATEREQUALTHAN reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    EQUALS          reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    NOTEQUALS       reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    $end            reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    WHILE           reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    SEMICOLON       reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    ELSE            reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    COMMA           reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    RCURLY          reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    RPAREN          reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .)
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETUNION        [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETDIFF         [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 45 (binaryOp -> binaryOp TIMES binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]


state 106

    (55) binaryOp -> binaryOp GREATERTHAN binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    OR              reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    LESSTHAN        reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    GREATERTHAN     reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    $end            reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    WHILE           reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    SEMICOLON       reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    ELSE            reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    COMMA           reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    RCURLY          reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    RPAREN          reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 55 (binaryOp -> binaryOp GREATERTHAN binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]


state 107

    (48) binaryOp -> binaryOp AND binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    OR              reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    $end            reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    WHILE           reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    SEMICOLON       reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    ELSE            reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    COMMA           reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    RCURLY          reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    RPAREN          reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    LESSTHAN        shift and go to state 49
    LESSEQUALTHAN   shift and go to state 64
    GREATERTHAN     shift and go to state 62
    GREATEREQUALTHAN shift and go to state 57
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! MINUS           [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! TIMES           [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! DIVIDE          [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! MODULE          [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! LESSTHAN        [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! LESSEQUALTHAN   [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! GREATERTHAN     [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! GREATEREQUALTHAN [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! EQUALS          [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETUNION        [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETDIFF         [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 48 (binaryOp -> binaryOp AND binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]


state 108

    (54) binaryOp -> binaryOp LESSEQUALTHAN binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    AND             reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    OR              reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    LESSTHAN        reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    LESSEQUALTHAN   reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    GREATERTHAN     reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    GREATEREQUALTHAN reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    $end            reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    WHILE           reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    SEMICOLON       reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    ELSE            reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    COMMA           reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    RCURLY          reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    RPAREN          reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! MINUS           [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! TIMES           [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! DIVIDE          [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! MODULE          [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! EQUALS          [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETUNION        [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETDIFF         [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 54 (binaryOp -> binaryOp LESSEQUALTHAN binaryOp .) ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]


state 109

    (62) binaryOp -> binaryOp SETMAPPLUS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    MINUS           reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    TIMES           reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    DIVIDE          reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    MODULE          reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    AND             reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    OR              reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    LESSTHAN        reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    GREATERTHAN     reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    EQUALS          reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    NOTEQUALS       reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETUNION        reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETDIFF         reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETINTERSECT    reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETMAPPLUS      reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETMAPMINUS     reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    $end            reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    WHILE           reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SEMICOLON       reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    ELSE            reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    COMMA           reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    RCURLY          reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    RPAREN          reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .)
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETMAPTIMES     [ reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 62 (binaryOp -> binaryOp SETMAPPLUS binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]
  ! SETMAPPLUS      [ shift and go to state 65 ]
  ! SETMAPMINUS     [ shift and go to state 68 ]


state 110

    (49) binaryOp -> binaryOp OR binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    OR              reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    $end            reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    WHILE           reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    SEMICOLON       reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    ELSE            reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    COMMA           reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    RCURLY          reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    RPAREN          reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 51
    TIMES           shift and go to state 61
    DIVIDE          shift and go to state 58
    MODULE          shift and go to state 60
    AND             shift and go to state 63
    LESSTHAN        shift and go to state 49
    LESSEQUALTHAN   shift and go to state 64
    GREATERTHAN     shift and go to state 62
    GREATEREQUALTHAN shift and go to state 57
    EQUALS          shift and go to state 59
    NOTEQUALS       shift and go to state 48
    SETUNION        shift and go to state 52
    SETDIFF         shift and go to state 56
    SETINTERSECT    shift and go to state 54
    SETMAPPLUS      shift and go to state 65
    SETMAPMINUS     shift and go to state 68
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! PLUS            [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! MINUS           [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! TIMES           [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! DIVIDE          [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! MODULE          [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! AND             [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! LESSTHAN        [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! LESSEQUALTHAN   [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! GREATERTHAN     [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! GREATEREQUALTHAN [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! EQUALS          [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! NOTEQUALS       [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETUNION        [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETDIFF         [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETINTERSECT    [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPPLUS      [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPMINUS     [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPTIMES     [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 49 (binaryOp -> binaryOp OR binaryOp .) ]
  ! OR              [ shift and go to state 66 ]


state 111

    (65) binaryOp -> binaryOp SETMAPDIVIDE binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    MINUS           reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    TIMES           reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    DIVIDE          reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    MODULE          reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    AND             reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    OR              reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    LESSTHAN        reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    LESSEQUALTHAN   reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    GREATERTHAN     reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    GREATEREQUALTHAN reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    EQUALS          reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    NOTEQUALS       reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETUNION        reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETDIFF         reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETINTERSECT    reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPPLUS      reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPMINUS     reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPTIMES     reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPDIVIDE    reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SETMAPMODULE    reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    $end            reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    WHILE           reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    SEMICOLON       reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    ELSE            reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    COMMA           reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    RCURLY          reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    RPAREN          reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .)
    BELONGSTO       shift and go to state 69

  ! BELONGSTO       [ reduce using rule 65 (binaryOp -> binaryOp SETMAPDIVIDE binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]
  ! SETMAPPLUS      [ shift and go to state 65 ]
  ! SETMAPMINUS     [ shift and go to state 68 ]
  ! SETMAPTIMES     [ shift and go to state 53 ]
  ! SETMAPDIVIDE    [ shift and go to state 67 ]
  ! SETMAPMODULE    [ shift and go to state 50 ]


state 112

    (63) binaryOp -> binaryOp SETMAPMINUS binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    MINUS           reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    TIMES           reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    DIVIDE          reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    MODULE          reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    AND             reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    OR              reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    LESSTHAN        reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    LESSEQUALTHAN   reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    GREATERTHAN     reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    GREATEREQUALTHAN reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    EQUALS          reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    NOTEQUALS       reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETUNION        reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETDIFF         reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETINTERSECT    reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETMAPPLUS      reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETMAPMINUS     reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    $end            reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    WHILE           reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SEMICOLON       reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    ELSE            reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    COMMA           reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    RCURLY          reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    RPAREN          reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .)
    SETMAPTIMES     shift and go to state 53
    SETMAPDIVIDE    shift and go to state 67
    SETMAPMODULE    shift and go to state 50
    BELONGSTO       shift and go to state 69

  ! SETMAPTIMES     [ reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! SETMAPDIVIDE    [ reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! SETMAPMODULE    [ reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! BELONGSTO       [ reduce using rule 63 (binaryOp -> binaryOp SETMAPMINUS binaryOp .) ]
  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]
  ! SETMAPPLUS      [ shift and go to state 65 ]
  ! SETMAPMINUS     [ shift and go to state 68 ]


state 113

    (67) binaryOp -> binaryOp BELONGSTO binaryOp .
    (43) binaryOp -> binaryOp . PLUS binaryOp
    (44) binaryOp -> binaryOp . MINUS binaryOp
    (45) binaryOp -> binaryOp . TIMES binaryOp
    (46) binaryOp -> binaryOp . DIVIDE binaryOp
    (47) binaryOp -> binaryOp . MODULE binaryOp
    (48) binaryOp -> binaryOp . AND binaryOp
    (49) binaryOp -> binaryOp . OR binaryOp
    (53) binaryOp -> binaryOp . LESSTHAN binaryOp
    (54) binaryOp -> binaryOp . LESSEQUALTHAN binaryOp
    (55) binaryOp -> binaryOp . GREATERTHAN binaryOp
    (56) binaryOp -> binaryOp . GREATEREQUALTHAN binaryOp
    (57) binaryOp -> binaryOp . EQUALS binaryOp
    (58) binaryOp -> binaryOp . NOTEQUALS binaryOp
    (59) binaryOp -> binaryOp . SETUNION binaryOp
    (60) binaryOp -> binaryOp . SETDIFF binaryOp
    (61) binaryOp -> binaryOp . SETINTERSECT binaryOp
    (62) binaryOp -> binaryOp . SETMAPPLUS binaryOp
    (63) binaryOp -> binaryOp . SETMAPMINUS binaryOp
    (64) binaryOp -> binaryOp . SETMAPTIMES binaryOp
    (65) binaryOp -> binaryOp . SETMAPDIVIDE binaryOp
    (66) binaryOp -> binaryOp . SETMAPMODULE binaryOp
    (67) binaryOp -> binaryOp . BELONGSTO binaryOp

    PLUS            reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    MINUS           reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    TIMES           reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    DIVIDE          reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    MODULE          reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    AND             reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    OR              reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    LESSTHAN        reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    LESSEQUALTHAN   reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    GREATERTHAN     reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    GREATEREQUALTHAN reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    EQUALS          reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    NOTEQUALS       reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETUNION        reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETDIFF         reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETINTERSECT    reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPPLUS      reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPMINUS     reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPTIMES     reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPDIVIDE    reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SETMAPMODULE    reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    BELONGSTO       reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    $end            reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    WHILE           reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    SEMICOLON       reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    ELSE            reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    COMMA           reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    RCURLY          reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)
    RPAREN          reduce using rule 67 (binaryOp -> binaryOp BELONGSTO binaryOp .)

  ! PLUS            [ shift and go to state 55 ]
  ! MINUS           [ shift and go to state 51 ]
  ! TIMES           [ shift and go to state 61 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! MODULE          [ shift and go to state 60 ]
  ! AND             [ shift and go to state 63 ]
  ! OR              [ shift and go to state 66 ]
  ! LESSTHAN        [ shift and go to state 49 ]
  ! LESSEQUALTHAN   [ shift and go to state 64 ]
  ! GREATERTHAN     [ shift and go to state 62 ]
  ! GREATEREQUALTHAN [ shift and go to state 57 ]
  ! EQUALS          [ shift and go to state 59 ]
  ! NOTEQUALS       [ shift and go to state 48 ]
  ! SETUNION        [ shift and go to state 52 ]
  ! SETDIFF         [ shift and go to state 56 ]
  ! SETINTERSECT    [ shift and go to state 54 ]
  ! SETMAPPLUS      [ shift and go to state 65 ]
  ! SETMAPMINUS     [ shift and go to state 68 ]
  ! SETMAPTIMES     [ shift and go to state 53 ]
  ! SETMAPDIVIDE    [ shift and go to state 67 ]
  ! SETMAPMODULE    [ shift and go to state 50 ]
  ! BELONGSTO       [ shift and go to state 69 ]


state 114

    (52) binaryOp -> LPAREN binaryOp RPAREN .

    PLUS            reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    MINUS           reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    TIMES           reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    DIVIDE          reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    MODULE          reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    AND             reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    OR              reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    LESSTHAN        reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    LESSEQUALTHAN   reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    GREATERTHAN     reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    GREATEREQUALTHAN reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    EQUALS          reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    NOTEQUALS       reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETUNION        reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETDIFF         reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETINTERSECT    reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPPLUS      reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPMINUS     reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPTIMES     reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPDIVIDE    reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SETMAPMODULE    reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    BELONGSTO       reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    $end            reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    WHILE           reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    SEMICOLON       reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    ELSE            reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    COMMA           reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    RCURLY          reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)
    RPAREN          reduce using rule 52 (binaryOp -> LPAREN binaryOp RPAREN .)


state 115

    (41) outputType -> expression COMMA outputType .

    $end            reduce using rule 41 (outputType -> expression COMMA outputType .)
    WHILE           reduce using rule 41 (outputType -> expression COMMA outputType .)
    SEMICOLON       reduce using rule 41 (outputType -> expression COMMA outputType .)
    ELSE            reduce using rule 41 (outputType -> expression COMMA outputType .)


state 116

    (32) whileInst -> WHILE LPAREN expression RPAREN . DO instruction

    DO              shift and go to state 125


state 117

    (31) forInst -> FOR IDENTIFIER direction set . DO instruction

    DO              shift and go to state 126


state 118

    (30) forInst -> FOR IDENTIFIER direction IDENTIFIER . DO instruction

    DO              shift and go to state 127


state 119

    (28) ifInst -> IF LPAREN expression RPAREN . instruction
    (29) ifInst -> IF LPAREN expression RPAREN . instruction ELSE instruction
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 128
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 120

    (13) instructionBlock -> instruction SEMICOLON instructionBlock .

    RCURLY          reduce using rule 13 (instructionBlock -> instruction SEMICOLON instructionBlock .)


state 121

    (7) id -> IDENTIFIER .
    (8) id -> IDENTIFIER . COMMA id

    SEMICOLON       reduce using rule 7 (id -> IDENTIFIER .)
    COMMA           shift and go to state 129


state 122

    (2) declarationBlock -> types id . SEMICOLON
    (3) declarationBlock -> types id . SEMICOLON declarationBlock

    SEMICOLON       shift and go to state 130


state 123

    (24) usingInInst -> USING declarationBlock IN . instructionBlock
    (12) instructionBlock -> . instruction SEMICOLON
    (13) instructionBlock -> . instruction SEMICOLON instructionBlock
    (14) instructionBlock -> . empty
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (11) empty -> .
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    RCURLY          reduce using rule 11 (empty -> .)
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instructionBlock               shift and go to state 131
    scanInst                       shift and go to state 7
    instruction                    shift and go to state 43
    block                          shift and go to state 19
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    ifInst                         shift and go to state 11
    empty                          shift and go to state 42

state 124

    (26) setNumbers -> expression COMMA setNumbers .

    RCURLY          reduce using rule 26 (setNumbers -> expression COMMA setNumbers .)


state 125

    (32) whileInst -> WHILE LPAREN expression RPAREN DO . instruction
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 132
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 126

    (31) forInst -> FOR IDENTIFIER direction set DO . instruction
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 133
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 127

    (30) forInst -> FOR IDENTIFIER direction IDENTIFIER DO . instruction
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 134
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 128

    (28) ifInst -> IF LPAREN expression RPAREN instruction .
    (29) ifInst -> IF LPAREN expression RPAREN instruction . ELSE instruction

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 28 (ifInst -> IF LPAREN expression RPAREN instruction .)
    WHILE           reduce using rule 28 (ifInst -> IF LPAREN expression RPAREN instruction .)
    $end            reduce using rule 28 (ifInst -> IF LPAREN expression RPAREN instruction .)
    ELSE            shift and go to state 135

  ! ELSE            [ reduce using rule 28 (ifInst -> IF LPAREN expression RPAREN instruction .) ]


state 129

    (8) id -> IDENTIFIER COMMA . id
    (7) id -> . IDENTIFIER
    (8) id -> . IDENTIFIER COMMA id

    IDENTIFIER      shift and go to state 121

    id                             shift and go to state 136

state 130

    (2) declarationBlock -> types id SEMICOLON .
    (3) declarationBlock -> types id SEMICOLON . declarationBlock
    (2) declarationBlock -> . types id SEMICOLON
    (3) declarationBlock -> . types id SEMICOLON declarationBlock
    (4) types -> . INT
    (5) types -> . BOOL
    (6) types -> . SET

    IN              reduce using rule 2 (declarationBlock -> types id SEMICOLON .)
    INT             shift and go to state 86
    BOOL            shift and go to state 87
    SET             shift and go to state 85

    types                          shift and go to state 88
    declarationBlock               shift and go to state 137

state 131

    (24) usingInInst -> USING declarationBlock IN instructionBlock .

    RCURLY          reduce using rule 24 (usingInInst -> USING declarationBlock IN instructionBlock .)


state 132

    (32) whileInst -> WHILE LPAREN expression RPAREN DO instruction .

    $end            reduce using rule 32 (whileInst -> WHILE LPAREN expression RPAREN DO instruction .)
    SEMICOLON       reduce using rule 32 (whileInst -> WHILE LPAREN expression RPAREN DO instruction .)
    WHILE           reduce using rule 32 (whileInst -> WHILE LPAREN expression RPAREN DO instruction .)
    ELSE            reduce using rule 32 (whileInst -> WHILE LPAREN expression RPAREN DO instruction .)


state 133

    (31) forInst -> FOR IDENTIFIER direction set DO instruction .

    $end            reduce using rule 31 (forInst -> FOR IDENTIFIER direction set DO instruction .)
    ELSE            reduce using rule 31 (forInst -> FOR IDENTIFIER direction set DO instruction .)
    WHILE           reduce using rule 31 (forInst -> FOR IDENTIFIER direction set DO instruction .)
    SEMICOLON       reduce using rule 31 (forInst -> FOR IDENTIFIER direction set DO instruction .)


state 134

    (30) forInst -> FOR IDENTIFIER direction IDENTIFIER DO instruction .

    $end            reduce using rule 30 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instruction .)
    ELSE            reduce using rule 30 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instruction .)
    WHILE           reduce using rule 30 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instruction .)
    SEMICOLON       reduce using rule 30 (forInst -> FOR IDENTIFIER direction IDENTIFIER DO instruction .)


state 135

    (29) ifInst -> IF LPAREN expression RPAREN instruction ELSE . instruction
    (15) instruction -> . IDENTIFIER ASSIGN expression
    (16) instruction -> . IDENTIFIER ASSIGN set
    (17) instruction -> . ifInst
    (18) instruction -> . printOutput
    (19) instruction -> . whileInst
    (20) instruction -> . repeatInst
    (21) instruction -> . forInst
    (22) instruction -> . scanInst
    (23) instruction -> . block
    (28) ifInst -> . IF LPAREN expression RPAREN instruction
    (29) ifInst -> . IF LPAREN expression RPAREN instruction ELSE instruction
    (37) printOutput -> . PRINT outputType
    (38) printOutput -> . PRINTLN outputType
    (32) whileInst -> . WHILE LPAREN expression RPAREN DO instruction
    (33) repeatInst -> . REPEAT instruction whileInst
    (30) forInst -> . FOR IDENTIFIER direction IDENTIFIER DO instruction
    (31) forInst -> . FOR IDENTIFIER direction set DO instruction
    (34) scanInst -> . SCAN expression
    (9) block -> . LCURLY usingInInst RCURLY
    (10) block -> . LCURLY instructionBlock RCURLY

    IDENTIFIER      shift and go to state 10
    IF              shift and go to state 16
    PRINT           shift and go to state 5
    PRINTLN         shift and go to state 8
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    FOR             shift and go to state 14
    SCAN            shift and go to state 4
    LCURLY          shift and go to state 17

    printOutput                    shift and go to state 13
    forInst                        shift and go to state 3
    instruction                    shift and go to state 138
    scanInst                       shift and go to state 7
    repeatInst                     shift and go to state 15
    whileInst                      shift and go to state 9
    block                          shift and go to state 19
    ifInst                         shift and go to state 11

state 136

    (8) id -> IDENTIFIER COMMA id .

    SEMICOLON       reduce using rule 8 (id -> IDENTIFIER COMMA id .)


state 137

    (3) declarationBlock -> types id SEMICOLON declarationBlock .

    IN              reduce using rule 3 (declarationBlock -> types id SEMICOLON declarationBlock .)


state 138

    (29) ifInst -> IF LPAREN expression RPAREN instruction ELSE instruction .

    SEMICOLON       reduce using rule 29 (ifInst -> IF LPAREN expression RPAREN instruction ELSE instruction .)
    WHILE           reduce using rule 29 (ifInst -> IF LPAREN expression RPAREN instruction ELSE instruction .)
    ELSE            reduce using rule 29 (ifInst -> IF LPAREN expression RPAREN instruction ELSE instruction .)
    $end            reduce using rule 29 (ifInst -> IF LPAREN expression RPAREN instruction ELSE instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 128 resolved as shift
WARNING: reduce/reduce conflict in state 75 resolved using rule (instruction -> IDENTIFIER ASSIGN set)
WARNING: rejected rule (binaryOp -> set) in state 75
WARNING: reduce/reduce conflict in state 83 resolved using rule (empty -> <empty>)
WARNING: rejected rule (instructionBlock -> instruction SEMICOLON) in state 83
WARNING: Rule (instructionBlock -> instruction SEMICOLON) is never reduced
